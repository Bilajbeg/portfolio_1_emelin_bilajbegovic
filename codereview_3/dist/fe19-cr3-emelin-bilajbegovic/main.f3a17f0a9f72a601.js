"use strict"; (self.webpackChunkFE19_CR3_EMELIN_BILAJBEGOVIC = self.webpackChunkFE19_CR3_EMELIN_BILAJBEGOVIC || []).push([[179], { 195: () => { function te(e) { return "function" == typeof e } function Yr(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const vi = Yr(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function Kr(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class at { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (te(r)) try { r() } catch (i) { t = i instanceof vi ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Sd(i) } catch (s) { t = t ?? [], s instanceof vi ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new vi(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Sd(t); else { if (t instanceof at) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && Kr(n, t) } remove(t) { const { _finalizers: n } = this; n && Kr(n, t), t instanceof at && t._removeParent(this) } } at.EMPTY = (() => { const e = new at; return e.closed = !0, e })(); const bd = at.EMPTY; function Id(e) { return e instanceof at || e && "closed" in e && te(e.remove) && te(e.add) && te(e.unsubscribe) } function Sd(e) { te(e) ? e() : e.unsubscribe() } const Sn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Di = { setTimeout(e, t, ...n) { const { delegate: r } = Di; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = Di; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Md(e) { Di.setTimeout(() => { const { onUnhandledError: t } = Sn; if (!t) throw e; t(e) }) } function Td() { } const LC = Sa("C", void 0, void 0); function Sa(e, t, n) { return { kind: e, value: t, error: n } } let Mn = null; function Ci(e) { if (Sn.useDeprecatedSynchronousErrorHandling) { const t = !Mn; if (t && (Mn = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = Mn; if (Mn = null, n) throw r } } else e() } class Ma extends at { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Id(t) && t.add(this)) : this.destination = zC } static create(t, n, r) { return new Jr(t, n, r) } next(t) { this.isStopped ? Aa(function VC(e) { return Sa("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? Aa(function jC(e) { return Sa("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? Aa(LC, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const HC = Function.prototype.bind; function Ta(e, t) { return HC.call(e, t) } class BC { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { wi(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { wi(r) } else wi(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { wi(n) } } } class Jr extends Ma { constructor(t, n, r) { let o; if (super(), te(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && Sn.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && Ta(t.next, i), error: t.error && Ta(t.error, i), complete: t.complete && Ta(t.complete, i) }) : o = t } this.destination = new BC(o) } } function wi(e) { Sn.useDeprecatedSynchronousErrorHandling ? function $C(e) { Sn.useDeprecatedSynchronousErrorHandling && Mn && (Mn.errorThrown = !0, Mn.error = e) }(e) : Md(e) } function Aa(e, t) { const { onStoppedNotification: n } = Sn; n && Di.setTimeout(() => n(e, t)) } const zC = { closed: !0, next: Td, error: function UC(e) { throw e }, complete: Td }, Na = "function" == typeof Symbol && Symbol.observable || "@@observable"; function ln(e) { return e } function Ad(e) { return 0 === e.length ? ln : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } } let Ce = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function qC(e) { return e && e instanceof Ma || function WC(e) { return e && te(e.next) && te(e.error) && te(e.complete) }(e) && Id(e) }(n) ? n : new Jr(n, r, o); return Ci(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Nd(r))((o, i) => { const s = new Jr({ next: a => { try { n(a) } catch (u) { i(u), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [Na]() { return this } pipe(...n) { return Ad(n)(this) } toPromise(n) { return new (n = Nd(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function Nd(e) { var t; return null !== (t = e ?? Sn.Promise) && void 0 !== t ? t : Promise } const ZC = Yr(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Gt = (() => { class e extends Ce { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Rd(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new ZC } next(n) { Ci(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { Ci(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { Ci(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? bd : (this.currentObservers = null, i.push(n), new at(() => { this.currentObservers = null, Kr(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new Ce; return n.source = this, n } } return e.create = (t, n) => new Rd(t, n), e })(); class Rd extends Gt { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : bd } } class ut extends Gt { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { const { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } } function xd(e) { return te(e?.lift) } function Se(e) { return t => { if (xd(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Me(e, t, n, r, o) { return new QC(e, t, n, r, o) } class QC extends Ma { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function re(e, t) { return Se((n, r) => { let o = 0; n.subscribe(Me(r, i => { r.next(e.call(t, i, o++)) })) }) } function dn(e) { return this instanceof dn ? (this.v = e, this) : new dn(e) } function kd(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function Pa(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, u) { !function o(i, s, a, u) { Promise.resolve(u).then(function (c) { i({ value: c, done: a }) }, s) }(a, u, (s = e[i](s)).done, s.value) }) } } } const Ld = e => e && "number" == typeof e.length && "function" != typeof e; function jd(e) { return te(e?.then) } function Vd(e) { return te(e[Na]) } function $d(e) { return Symbol.asyncIterator && te(e?.[Symbol.asyncIterator]) } function Hd(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Bd = function pw() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Ud(e) { return te(e?.[Bd]) } function zd(e) { return function Fd(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function u(f) { f.value instanceof dn ? Promise.resolve(f.value.v).then(c, l) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function c(f) { a("next", f) } function l(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } }(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield dn(n.read()); if (o) return yield dn(void 0); yield yield dn(r) } } finally { n.releaseLock() } }) } function Gd(e) { return te(e?.getReader) } function mt(e) { if (e instanceof Ce) return e; if (null != e) { if (Vd(e)) return function gw(e) { return new Ce(t => { const n = e[Na](); if (te(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (Ld(e)) return function mw(e) { return new Ce(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (jd(e)) return function yw(e) { return new Ce(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, Md) }) }(e); if ($d(e)) return Wd(e); if (Ud(e)) return function vw(e) { return new Ce(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (Gd(e)) return function Dw(e) { return Wd(zd(e)) }(e) } throw Hd(e) } function Wd(e) { return new Ce(t => { (function Cw(e, t) { var n, r, o, i; return function Od(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(l) { try { c(r.next(l)) } catch (d) { s(d) } } function u(l) { try { c(r.throw(l)) } catch (d) { s(d) } } function c(l) { l.done ? i(l.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(l.value).then(a, u) } c((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = kd(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function Wt(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function Ae(e, t, n = 1 / 0) { return te(t) ? Ae((r, o) => re((i, s) => t(r, i, o, s))(mt(e(r, o))), n) : ("number" == typeof t && (n = t), Se((r, o) => function ww(e, t, n, r, o, i, s, a) { const u = []; let c = 0, l = 0, d = !1; const f = () => { d && !u.length && !c && t.complete() }, h = g => c < r ? p(g) : u.push(g), p = g => { i && t.next(g), c++; let v = !1; mt(n(g, l++)).subscribe(Me(t, D => { o?.(D), i ? h(D) : t.next(D) }, () => { v = !0 }, void 0, () => { if (v) try { for (c--; u.length && c < r;) { const D = u.shift(); s ? Wt(t, s, () => p(D)) : p(D) } f() } catch (D) { t.error(D) } })) }; return e.subscribe(Me(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } function Yn(e = 1 / 0) { return Ae(ln, e) } const Mt = new Ce(e => e.complete()); function Fa(e) { return e[e.length - 1] } function Xr(e) { return function _w(e) { return e && te(e.schedule) }(Fa(e)) ? e.pop() : void 0 } function qd(e, t = 0) { return Se((n, r) => { n.subscribe(Me(r, o => Wt(r, e, () => r.next(o), t), () => Wt(r, e, () => r.complete(), t), o => Wt(r, e, () => r.error(o), t))) }) } function Zd(e, t = 0) { return Se((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function Qd(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new Ce(n => { Wt(n, t, () => { const r = e[Symbol.asyncIterator](); Wt(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function Ne(e, t) { return t ? function Rw(e, t) { if (null != e) { if (Vd(e)) return function Sw(e, t) { return mt(e).pipe(Zd(t), qd(t)) }(e, t); if (Ld(e)) return function Tw(e, t) { return new Ce(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (jd(e)) return function Mw(e, t) { return mt(e).pipe(Zd(t), qd(t)) }(e, t); if ($d(e)) return Qd(e, t); if (Ud(e)) return function Aw(e, t) { return new Ce(n => { let r; return Wt(n, t, () => { r = e[Bd](), Wt(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => te(r?.return) && r.return() }) }(e, t); if (Gd(e)) return function Nw(e, t) { return Qd(zd(e), t) }(e, t) } throw Hd(e) }(e, t) : mt(e) } function F(...e) { return Ne(e, Xr(e)) } function Yd(e = {}) { const { connector: t = (() => new Gt), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, u, c = 0, l = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = u = void 0, l = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return Se((g, v) => { c++, !d && !l && f(); const D = u = u ?? t(); v.add(() => { c--, 0 === c && !d && !l && (a = ka(p, o)) }), D.subscribe(v), !s && c > 0 && (s = new Jr({ next: m => D.next(m), error: m => { d = !0, f(), a = ka(h, n, m), D.error(m) }, complete: () => { l = !0, f(), a = ka(h, r), D.complete() } }), mt(g).subscribe(s)) })(i) } } function ka(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new Jr({ next: () => { r.unsubscribe(), e() } }); return mt(t(...n)).subscribe(r) } function Tt(e, t) { return Se((n, r) => { let o = null, i = 0, s = !1; const a = () => s && !o && r.complete(); n.subscribe(Me(r, u => { o?.unsubscribe(); let c = 0; const l = i++; mt(e(u, l)).subscribe(o = Me(r, d => r.next(t ? t(u, d, l, c++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function Pw(e, t) { return e === t } function X(e) { for (let t in e) if (e[t] === X) return t; throw Error("Could not find renamed property on target object.") } function we(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(we).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function La(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const Fw = X({ __forward_ref__: X }); function ja(e) { return e.__forward_ref__ = ja, e.toString = function () { return we(this()) }, e } function k(e) { return Va(e) ? e() : e } function Va(e) { return "function" == typeof e && e.hasOwnProperty(Fw) && e.__forward_ref__ === ja } function $a(e) { return e && !!e.\u0275providers } const Kd = "https://g.co/ng/security#xss"; class C extends Error { constructor(t, n) { super(function _i(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t : ""}` }(t, n)), this.code = t } } function L(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function bi(e, t) { throw new C(-201, !1) } function ct(e, t) { null == e && function J(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function x(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function hn(e) { return { providers: e.providers || [], imports: e.imports || [] } } function Ii(e) { return Jd(e, Si) || Jd(e, ef) } function Jd(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function Xd(e) { return e && (e.hasOwnProperty(Ha) || e.hasOwnProperty(Uw)) ? e[Ha] : null } const Si = X({ \u0275prov: X }), Ha = X({ \u0275inj: X }), ef = X({ ngInjectableDef: X }), Uw = X({ ngInjectorDef: X }); var A = (() => ((A = A || {})[A.Default = 0] = "Default", A[A.Host = 1] = "Host", A[A.Self = 2] = "Self", A[A.SkipSelf = 4] = "SkipSelf", A[A.Optional = 8] = "Optional", A))(); let Ba; function Ge(e) { const t = Ba; return Ba = e, t } function nf(e, t, n) { const r = Ii(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & A.Optional ? null : void 0 !== t ? t : void bi(we(e)) } const oe = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), eo = {}, Ua = "__NG_DI_FLAG__", Mi = "ngTempTokenPath", Gw = /\n/gm, rf = "__source"; let Kn; function pn(e) { const t = Kn; return Kn = e, t } function Zw(e, t = A.Default) { if (void 0 === Kn) throw new C(-203, !1); return null === Kn ? nf(e, void 0, t) : Kn.get(e, t & A.Optional ? null : void 0, t) } function R(e, t = A.Default) { return (function tf() { return Ba }() || Zw)(k(e), t) } function _(e, t = A.Default) { return R(e, Ti(t)) } function Ti(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function za(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = k(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new C(900, !1); let o, i = A.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = Qw(a); "number" == typeof u ? -1 === u ? o = a.token : i |= u : o = a } t.push(R(o, i)) } else t.push(R(r)) } return t } function to(e, t) { return e[Ua] = t, e.prototype[Ua] = t, e } function Qw(e) { return e[Ua] } function qt(e) { return { toString: e }.toString() } var At = (() => ((At = At || {})[At.OnPush = 0] = "OnPush", At[At.Default = 1] = "Default", At))(), et = (() => { return (e = et || (et = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", et; var e })(); const Nt = {}, Q = [], Ai = X({ \u0275cmp: X }), Ga = X({ \u0275dir: X }), Wa = X({ \u0275pipe: X }), af = X({ \u0275mod: X }), Zt = X({ \u0275fac: X }), no = X({ __NG_ELEMENT_ID__: X }), uf = X({ __NG_ENV_ID__: X }); function cf(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } function qa(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; df(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function lf(e) { return 3 === e || 4 === e || 6 === e } function df(e) { return 64 === e.charCodeAt(0) } function ro(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || ff(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function ff(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } const hf = "ng-template"; function Jw(e, t, n) { let r = 0, o = !0; for (; r < e.length;) { let i = e[r++]; if ("string" == typeof i && o) { const s = e[r++]; if (n && "class" === i && -1 !== cf(s.toLowerCase(), t, 0)) return !0 } else { if (1 === i) { for (; r < e.length && "string" == typeof (i = e[r++]);)if (i.toLowerCase() === t) return !0; return !1 } "number" == typeof i && (o = !1) } } return !1 } function pf(e) { return 4 === e.type && e.value !== hf } function Xw(e, t, n) { return t === (4 !== e.type || n ? e.value : hf) } function eE(e, t, n) { let r = 4; const o = e.attrs || [], i = function rE(e) { for (let t = 0; t < e.length; t++)if (lf(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !Xw(e, u, n) || "" === u && 1 === t.length) { if (yt(r)) return !1; s = !0 } } else { const c = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!Jw(e.attrs, c, n)) { if (yt(r)) return !1; s = !0 } continue } const d = tE(8 & r ? "class" : u, o, pf(e), n); if (-1 === d) { if (yt(r)) return !1; s = !0; continue } if ("" !== c) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== cf(h, c, 0) || 2 & r && c !== f) { if (yt(r)) return !1; s = !0 } } } } else { if (!s && !yt(r) && !yt(u)) return !1; if (s && yt(u)) continue; s = !1, r = u | 1 & r } } return yt(r) || s } function yt(e) { return 0 == (1 & e) } function tE(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function oE(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function gf(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (eE(e, t[r], n)) return !0; return !1 } function mf(e, t) { return e ? ":not(" + t.trim() + ")" : t } function sE(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !yt(s) && (t += mf(i, o), o = ""), r = s, i = i || !yt(r); n++ } return "" !== o && (t += mf(i, o)), t } function Rt(e) { return qt(() => { const t = vf(e), n = { ...t, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === At.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: null, signals: e.signals ?? !1, data: e.data || {}, encapsulation: e.encapsulation || et.Emulated, styles: e.styles || Q, _: null, schemas: e.schemas || null, tView: null, id: "" }; Df(n); const r = e.dependencies; return n.directiveDefs = Ni(r, !1), n.pipeDefs = Ni(r, !0), n.id = function pE(e) { let t = 0; const n = [e.selectors, e.ngContentSelectors, e.hostVars, e.hostAttrs, e.consts, e.vars, e.decls, e.encapsulation, e.standalone, e.signals, e.exportAs, JSON.stringify(e.inputs), JSON.stringify(e.outputs), Object.getOwnPropertyNames(e.type.prototype), !!e.contentQueries, !!e.viewQuery].join("|"); for (const o of n) t = Math.imul(31, t) + o.charCodeAt(0) << 0; return t += 2147483648, "c" + t }(n), n }) } function lE(e) { return Y(e) || xe(e) } function dE(e) { return null !== e } function Tn(e) { return qt(() => ({ type: e.type, bootstrap: e.bootstrap || Q, declarations: e.declarations || Q, imports: e.imports || Q, exports: e.exports || Q, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function yf(e, t) { if (null == e) return Nt; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } function je(e) { return qt(() => { const t = vf(e); return Df(t), t }) } function Y(e) { return e[Ai] || null } function xe(e) { return e[Ga] || null } function qe(e) { return e[Wa] || null } function tt(e, t) { const n = e[af] || null; if (!n && !0 === t) throw new Error(`Type ${we(e)} does not have '\u0275mod' property.`); return n } function vf(e) { const t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, inputTransforms: null, inputConfig: e.inputs || Nt, exportAs: e.exportAs || null, standalone: !0 === e.standalone, signals: !0 === e.signals, selectors: e.selectors || Q, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: yf(e.inputs, t), outputs: yf(e.outputs) } } function Df(e) { e.features?.forEach(t => t(e)) } function Ni(e, t) { if (!e) return null; const n = t ? qe : lE; return () => ("function" == typeof e ? e() : e).map(r => n(r)).filter(dE) } const Ee = 0, E = 1, V = 2, ae = 3, vt = 4, oo = 5, Oe = 6, Xn = 7, ge = 8, er = 9, An = 10, $ = 11, io = 12, Cf = 13, tr = 14, me = 15, so = 16, nr = 17, xt = 18, ao = 19, wf = 20, gn = 21, Qt = 22, Ri = 23, xi = 24, q = 25, Za = 1, Ef = 2, Ot = 7, rr = 9, Pe = 11; function nt(e) { return Array.isArray(e) && "object" == typeof e[Za] } function Ze(e) { return Array.isArray(e) && !0 === e[Za] } function Qa(e) { return 0 != (4 & e.flags) } function Nn(e) { return e.componentOffset > -1 } function Pi(e) { return 1 == (1 & e.flags) } function Dt(e) { return !!e.template } function Ya(e) { return 0 != (512 & e[V]) } function Rn(e, t) { return e.hasOwnProperty(Zt) ? e[Zt] : null } let CE = oe.WeakRef ?? class DE { constructor(t) { this.ref = t } deref() { return this.ref } }, EE = 0, Pt = null, Fi = !1; function Te(e) { const t = Pt; return Pt = e, t } class Mf { constructor() { this.id = EE++, this.ref = function wE(e) { return new CE(e) }(this), this.producers = new Map, this.consumers = new Map, this.trackingVersion = 0, this.valueVersion = 0 } consumerPollProducersForChange() { for (const [t, n] of this.producers) { const r = n.producerNode.deref(); if (void 0 !== r && n.atTrackingVersion === this.trackingVersion) { if (r.producerPollStatus(n.seenValueVersion)) return !0 } else this.producers.delete(t), r?.consumers.delete(this.id) } return !1 } producerMayHaveChanged() { const t = Fi; Fi = !0; try { for (const [n, r] of this.consumers) { const o = r.consumerNode.deref(); void 0 !== o && o.trackingVersion === r.atTrackingVersion ? o.onConsumerDependencyMayHaveChanged() : (this.consumers.delete(n), o?.producers.delete(this.id)) } } finally { Fi = t } } producerAccessed() { if (Fi) throw new Error(""); if (null === Pt) return; let t = Pt.producers.get(this.id); void 0 === t ? (t = { consumerNode: Pt.ref, producerNode: this.ref, seenValueVersion: this.valueVersion, atTrackingVersion: Pt.trackingVersion }, Pt.producers.set(this.id, t), this.consumers.set(Pt.id, t)) : (t.seenValueVersion = this.valueVersion, t.atTrackingVersion = Pt.trackingVersion) } get hasProducers() { return this.producers.size > 0 } get producerUpdatesAllowed() { return !1 !== Pt?.consumerAllowSignalWrites } producerPollStatus(t) { return this.valueVersion !== t || (this.onProducerUpdateValueVersion(), this.valueVersion !== t) } } let Tf = null; const Nf = () => { }; class SE extends Mf { constructor(t, n, r) { super(), this.watch = t, this.schedule = n, this.dirty = !1, this.cleanupFn = Nf, this.registerOnCleanup = o => { this.cleanupFn = o }, this.consumerAllowSignalWrites = r } notify() { this.dirty || this.schedule(this), this.dirty = !0 } onConsumerDependencyMayHaveChanged() { this.notify() } onProducerUpdateValueVersion() { } run() { if (this.dirty = !1, 0 !== this.trackingVersion && !this.consumerPollProducersForChange()) return; const t = Te(this); this.trackingVersion++; try { this.cleanupFn(), this.cleanupFn = Nf, this.watch(this.registerOnCleanup) } finally { Te(t) } } cleanup() { this.cleanupFn() } } class ME { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function xn() { return Rf } function Rf(e) { return e.type.prototype.ngOnChanges && (e.setInput = AE), TE } function TE() { const e = Of(this), t = e?.current; if (t) { const n = e.previous; if (n === Nt) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function AE(e, t, n, r) { const o = this.declaredInputs[n], i = Of(e) || function NE(e, t) { return e[xf] = t }(e, { previous: Nt, current: null }), s = i.current || (i.current = {}), a = i.previous, u = a[o]; s[o] = new ME(u && u.currentValue, t, a === Nt), e[r] = t } xn.ngInherit = !0; const xf = "__ngSimpleChanges__"; function Of(e) { return e[xf] || null } const Ft = function (e, t, n) { }; function se(e) { for (; Array.isArray(e);)e = e[Ee]; return e } function Qe(e, t) { return se(t[e.index]) } function kf(e, t) { return e.data[t] } function rt(e, t) { const n = t[e]; return nt(n) ? n : n[Ee] } function mn(e, t) { return null == t ? null : e[t] } function Lf(e) { e[nr] = 0 } function LE(e) { 1024 & e[V] || (e[V] |= 1024, Vf(e, 1)) } function jf(e) { 1024 & e[V] && (e[V] &= -1025, Vf(e, -1)) } function Vf(e, t) { let n = e[ae]; if (null === n) return; n[oo] += t; let r = n; for (n = n[ae]; null !== n && (1 === t && 1 === r[oo] || -1 === t && 0 === r[oo]);)n[oo] += t, r = n, n = n[ae] } const P = { lFrame: Jf(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; function Bf() { return P.bindingsEnabled } function y() { return P.lFrame.lView } function Z() { return P.lFrame.tView } function Re() { let e = Gf(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Gf() { return P.lFrame.currentTNode } function kt(e, t) { const n = P.lFrame; n.currentTNode = e, n.isParent = t } function nu() { return P.lFrame.isParent } function sr() { return P.lFrame.bindingIndex++ } function QE(e, t) { const n = P.lFrame; n.bindingIndex = n.bindingRootIndex = e, ou(t) } function ou(e) { P.lFrame.currentDirectiveIndex = e } function su(e) { P.lFrame.currentQueryIndex = e } function KE(e) { const t = e[E]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[Oe] : null } function Yf(e, t, n) { if (n & A.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & A.Host || (o = KE(i), null === o || (i = i[tr], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = P.lFrame = Kf(); return r.currentTNode = t, r.lView = e, !0 } function au(e) { const t = Kf(), n = e[E]; P.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function Kf() { const e = P.lFrame, t = null === e ? null : e.child; return null === t ? Jf(e) : t } function Jf(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function Xf() { const e = P.lFrame; return P.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const eh = Xf; function uu() { const e = Xf(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function $e() { return P.lFrame.selectedIndex } function On(e) { P.lFrame.selectedIndex = e } function ue() { const e = P.lFrame; return kf(e.tView, e.selectedIndex) } let nh = !0; function Vi() { return nh } function yn(e) { nh = e } function $i(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: c, ngOnDestroy: l } = i; s && (e.contentHooks ??= []).push(-n, s), a && ((e.contentHooks ??= []).push(n, a), (e.contentCheckHooks ??= []).push(n, a)), u && (e.viewHooks ??= []).push(-n, u), c && ((e.viewHooks ??= []).push(n, c), (e.viewCheckHooks ??= []).push(n, c)), null != l && (e.destroyHooks ??= []).push(n, l) } } function Hi(e, t, n) { rh(e, t, 3, n) } function Bi(e, t, n, r) { (3 & e[V]) === n && rh(e, t, n, r) } function cu(e, t) { let n = e[V]; (3 & n) === t && (n &= 8191, n += 1, e[V] = n) } function rh(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[nr] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[nr] += 65536), (a < i || -1 == i) && (i_(e, n, t, u), e[nr] = (4294901760 & e[nr]) + u + 2), u++ } function oh(e, t) { Ft(4, e, t); const n = Te(null); try { t.call(e) } finally { Te(n), Ft(5, e, t) } } function i_(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; o ? e[V] >> 13 < e[nr] >> 16 && (3 & e[V]) === t && (e[V] += 8192, oh(a, i)) : oh(a, i) } const ar = -1; class lo { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function ih(e) { return e !== ar } function Ui(e) { return 32767 & e } function zi(e, t) { let n = function c_(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[tr], n--; return r } let du = !0; function Gi(e) { const t = du; return du = e, t } const sh = 255, ah = 5; let l_ = 0; const Lt = {}; function Wi(e, t) { const n = uh(e, t); if (-1 !== n) return n; const r = t[E]; r.firstCreatePass && (e.injectorIndex = t.length, fu(r.data, e), fu(t, null), fu(r.blueprint, null)); const o = hu(e, t), i = e.injectorIndex; if (ih(o)) { const s = Ui(o), a = zi(o, t), u = a[E].data; for (let c = 0; c < 8; c++)t[i + c] = a[s + c] | u[s + c] } return t[i + 8] = o, i } function fu(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function uh(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function hu(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = mh(o), null === r) return ar; if (n++, o = o[tr], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return ar } function pu(e, t, n) { !function d_(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(no) && (r = n[no]), null == r && (r = n[no] = l_++); const o = r & sh; t.data[e + (o >> ah)] |= 1 << o }(e, t, n) } function ch(e, t, n) { if (n & A.Optional || void 0 !== e) return e; bi() } function lh(e, t, n, r) { if (n & A.Optional && void 0 === r && (r = null), !(n & (A.Self | A.Host))) { const o = e[er], i = Ge(void 0); try { return o ? o.get(t, r, n & A.Optional) : nf(t, r, n & A.Optional) } finally { Ge(i) } } return ch(r, 0, n) } function dh(e, t, n, r = A.Default, o) { if (null !== e) { if (2048 & t[V] && !(r & A.Self)) { const s = function m_(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 2048 & s[V] && !(512 & s[V]);) { const a = fh(i, s, n, r | A.Self, Lt); if (a !== Lt) return a; let u = i.parent; if (!u) { const c = s[wf]; if (c) { const l = c.get(n, Lt, r); if (l !== Lt) return l } u = mh(s), s = s[tr] } i = u } return o }(e, t, n, r, Lt); if (s !== Lt) return s } const i = fh(e, t, n, r, Lt); if (i !== Lt) return i } return lh(t, n, r, o) } function fh(e, t, n, r, o) { const i = function p_(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(no) ? e[no] : void 0; return "number" == typeof t ? t >= 0 ? t & sh : g_ : t }(n); if ("function" == typeof i) { if (!Yf(t, e, r)) return r & A.Host ? ch(o, 0, r) : lh(t, n, r, o); try { const s = i(r); if (null != s || r & A.Optional) return s; bi() } finally { eh() } } else if ("number" == typeof i) { let s = null, a = uh(e, t), u = ar, c = r & A.Host ? t[me][Oe] : null; for ((-1 === a || r & A.SkipSelf) && (u = -1 === a ? hu(e, t) : t[a + 8], u !== ar && ph(r, !1) ? (s = t[E], a = Ui(u), t = zi(u, t)) : a = -1); -1 !== a;) { const l = t[E]; if (hh(i, a, l.data)) { const d = h_(a, t, n, s, r, c); if (d !== Lt) return d } u = t[a + 8], u !== ar && ph(r, t[E].data[a + 8] === c) && hh(i, a, t) ? (s = l, a = Ui(u), t = zi(u, t)) : a = -1 } } return o } function h_(e, t, n, r, o, i) { const s = t[E], a = s.data[e + 8], l = function qi(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, u = e.directiveStart, l = i >> 20, f = o ? a + l : e.directiveEnd; for (let h = r ? a : a + l; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (o) { const h = s[u]; if (h && Dt(h) && h.type === n) return u } return null }(a, s, n, null == r ? Nn(a) && du : r != s && 0 != (3 & a.type), o & A.Host && i === a); return null !== l ? Pn(t, s, l, a) : Lt } function Pn(e, t, n, r) { let o = e[n]; const i = t.data; if (function s_(e) { return e instanceof lo }(o)) { const s = o; s.resolving && function kw(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new C(-200, `Circular dependency in DI detected for ${e}${n}`) }(function K(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : L(e) }(i[n])); const a = Gi(s.canSeeViewProviders); s.resolving = !0; const u = s.injectImpl ? Ge(s.injectImpl) : null; Yf(e, r, A.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function o_(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = Rf(t); (n.preOrderHooks ??= []).push(e, s), (n.preOrderCheckHooks ??= []).push(e, s) } o && (n.preOrderHooks ??= []).push(0 - e, o), i && ((n.preOrderHooks ??= []).push(e, i), (n.preOrderCheckHooks ??= []).push(e, i)) }(n, i[n], t) } finally { null !== u && Ge(u), Gi(a), s.resolving = !1, eh() } } return o } function hh(e, t, n) { return !!(n[t + (e >> ah)] & 1 << e) } function ph(e, t) { return !(e & A.Self || e & A.Host && t) } class ur { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return dh(this._tNode, this._lView, t, Ti(r), n) } } function g_() { return new ur(Re(), y()) } function gu(e) { return Va(e) ? () => { const t = gu(k(e)); return t && t() } : Rn(e) } function mh(e) { const t = e[E], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[Oe] : null } const lr = "__parameters__"; function fr(e, t, n) { return qt(() => { const r = function mu(e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(u, c, l) { const d = u.hasOwnProperty(lr) ? u[lr] : Object.defineProperty(u, lr, { value: [] })[lr]; for (; d.length <= l;)d.push(null); return (d[l] = d[l] || []).push(s), u } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } function po(e, t) { e.forEach(n => Array.isArray(n) ? po(n, t) : t(n)) } function vh(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function Qi(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } const Ki = to(fr("Optional"), 8), Ji = to(fr("SkipSelf"), 4); function ns(e) { return 128 == (128 & e.flags) } var Ye = (() => ((Ye = Ye || {})[Ye.Important = 1] = "Important", Ye[Ye.DashCase = 2] = "DashCase", Ye))(); const _u = new Map; let G_ = 0; const Iu = "__ngContext__"; function Fe(e, t) { nt(t) ? (e[Iu] = t[ao], function q_(e) { _u.set(e[ao], e) }(t)) : e[Iu] = t } let Su; function Mu(e, t) { return Su(e, t) } function vo(e) { const t = e[ae]; return Ze(t) ? t[ae] : t } function Vh(e) { return Hh(e[io]) } function $h(e) { return Hh(e[vt]) } function Hh(e) { for (; null !== e && !Ze(e);)e = e[vt]; return e } function mr(e, t, n, r, o) { if (null != r) { let i, s = !1; Ze(r) ? i = r : nt(r) && (s = !0, r = r[Ee]); const a = se(r); 0 === e && null !== n ? null == o ? Wh(t, n, a) : Fn(t, n, a, o || null, !0) : 1 === e && null !== n ? Fn(t, n, a, o || null, !0) : 2 === e ? function us(e, t, n) { const r = ss(e, t); r && function fb(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function gb(e, t, n, r, o) { const i = n[Ot]; i !== se(n) && mr(t, e, r, i, o); for (let a = Pe; a < n.length; a++) { const u = n[a]; Co(u[E], u, e, t, r, i) } }(t, e, i, n, o) } } function is(e, t, n) { return e.createElement(t, n) } function Uh(e, t) { const n = e[rr], r = n.indexOf(t); jf(t), n.splice(r, 1) } function Au(e, t) { if (e.length <= Pe) return; const n = Pe + t, r = e[n]; if (r) { const o = r[so]; null !== o && o !== e && Uh(o, r), t > 0 && (e[n - 1][vt] = r[vt]); const i = Qi(e, Pe + t); !function ob(e, t) { Co(e, t, t[$], 2, null, null), t[Ee] = null, t[Oe] = null }(r[E], r); const s = i[xt]; null !== s && s.detachView(i[E]), r[ae] = null, r[vt] = null, r[V] &= -129 } return r } function zh(e, t) { if (!(256 & t[V])) { const n = t[$]; t[Ri]?.destroy(), t[xi]?.destroy(), n.destroyNode && Co(e, t, n, 3, null, null), function ab(e) { let t = e[io]; if (!t) return Nu(e[E], e); for (; t;) { let n = null; if (nt(t)) n = t[io]; else { const r = t[Pe]; r && (n = r) } if (!n) { for (; t && !t[vt] && t !== e;)nt(t) && Nu(t[E], t), t = t[ae]; null === t && (t = e), nt(t) && Nu(t[E], t), n = t && t[vt] } t = n } }(t) } } function Nu(e, t) { if (!(256 & t[V])) { t[V] &= -129, t[V] |= 256, function db(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof lo)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], u = i[s + 1]; Ft(4, a, u); try { u.call(a) } finally { Ft(5, a, u) } } else { Ft(4, o, i); try { i.call(o) } finally { Ft(5, o, i) } } } } }(e, t), function lb(e, t) { const n = e.cleanup, r = t[Xn]; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 3]; s >= 0 ? r[s]() : r[-s].unsubscribe(), i += 2 } else n[i].call(r[n[i + 1]]); null !== r && (t[Xn] = null); const o = t[gn]; if (null !== o) { t[gn] = null; for (let i = 0; i < o.length; i++)(0, o[i])() } }(e, t), 1 === t[E].type && t[$].destroy(); const n = t[so]; if (null !== n && Ze(t[ae])) { n !== t[ae] && Uh(n, t); const r = t[xt]; null !== r && r.detachView(e) } !function Z_(e) { _u.delete(e[ao]) }(t) } } function Ru(e, t, n) { return function Gh(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[Ee]; { const { componentOffset: o } = r; if (o > -1) { const { encapsulation: i } = e.data[r.directiveStart + o]; if (i === et.None || i === et.Emulated) return null } return Qe(r, n) } }(e, t.parent, n) } function Fn(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function Wh(e, t, n) { e.appendChild(t, n) } function qh(e, t, n, r, o) { null !== r ? Fn(e, t, n, r, o) : Wh(e, t, n) } function ss(e, t) { return e.parentNode(t) } let xu, ku, ls, Yh = function Qh(e, t, n) { return 40 & e.type ? Qe(e, n) : null }; function as(e, t, n, r) { const o = Ru(e, r, t), i = t[$], a = function Zh(e, t, n) { return Yh(e, t, n) }(r.parent || t[Oe], r, t); if (null != o) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)qh(i, o, n[u], a, !1); else qh(i, o, n, a, !1); void 0 !== xu && xu(i, r, t, n, o) } function Do(e, t) { if (null !== t) { const n = t.type; if (3 & n) return Qe(t, e); if (4 & n) return Ou(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return Do(e, r); { const o = e[t.index]; return Ze(o) ? Ou(-1, o) : se(o) } } if (32 & n) return Mu(t, e)() || se(e[t.index]); { const r = Jh(e, t); return null !== r ? Array.isArray(r) ? r[0] : Do(vo(e[me]), r) : Do(e, t.next) } } return null } function Jh(e, t) { return null !== t ? e[me][Oe].projection[t.projection] : null } function Ou(e, t) { const n = Pe + e + 1; if (n < t.length) { const r = t[n], o = r[E].firstChild; if (null !== o) return Do(r, o) } return t[Ot] } function Pu(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && Fe(se(a), r), n.flags |= 2), 32 != (32 & n.flags)) if (8 & u) Pu(e, t, n.child, r, o, i, !1), mr(t, e, o, a, i); else if (32 & u) { const c = Mu(n, r); let l; for (; l = c();)mr(t, e, o, l, i); mr(t, e, o, a, i) } else 16 & u ? ep(e, t, r, n, o, i) : mr(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function Co(e, t, n, r, o, i) { Pu(n, r, e.firstChild, t, o, i, !1) } function ep(e, t, n, r, o, i) { const s = n[me], u = s[Oe].projection[r.projection]; if (Array.isArray(u)) for (let c = 0; c < u.length; c++)mr(t, e, o, u[c], i); else { let c = u; const l = s[ae]; ns(r) && (c.flags |= 128), Pu(e, t, c, l, o, i, !0) } } function tp(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function np(e, t, n) { const { mergedAttrs: r, classes: o, styles: i } = n; null !== r && qa(e, t, r), null !== o && tp(e, t, o), null !== i && function yb(e, t, n) { e.setAttribute(t, "style", n) }(e, t, i) } function ip(e) { return function Lu() { if (void 0 === ls && (ls = null, oe.trustedTypes)) try { ls = oe.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return ls }()?.createScriptURL(e) || e } class sp { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Kd})` } } function vn(e) { return e instanceof sp ? e.changingThisBreaksApplicationSecurity : e } function Eo(e, t) { const n = function Mb(e) { return e instanceof sp && e.getTypeName() || null }(e); if (null != n && n !== t) { if ("ResourceURL" === n && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${n} (see ${Kd})`) } return n === t } const Rb = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; var ye = (() => ((ye = ye || {})[ye.NONE = 0] = "NONE", ye[ye.HTML = 1] = "HTML", ye[ye.STYLE = 2] = "STYLE", ye[ye.SCRIPT = 3] = "SCRIPT", ye[ye.URL = 4] = "URL", ye[ye.RESOURCE_URL = 5] = "RESOURCE_URL", ye))(); function bo(e) { const t = Io(); return t ? t.sanitize(ye.URL, e) || "" : Eo(e, "URL") ? vn(e) : function ju(e) { return (e = String(e)).match(Rb) ? e : "unsafe:" + e }(L(e)) } function hp(e) { const t = Io(); if (t) return ip(t.sanitize(ye.RESOURCE_URL, e) || ""); if (Eo(e, "ResourceURL")) return ip(vn(e)); throw new C(904, !1) } function Io() { const e = y(); return e && e[An].sanitizer } class I { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = x({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } const So = new I("ENVIRONMENT_INITIALIZER"), gp = new I("INJECTOR", -1), mp = new I("INJECTOR_DEF_TYPES"); class yp { get(t, n = eo) { if (n === eo) { const r = new Error(`NullInjectorError: No provider for ${we(t)}!`); throw r.name = "NullInjectorError", r } return n } } function zb(...e) { return { \u0275providers: Dp(0, e), \u0275fromNgModule: !0 } } function Dp(e, ...t) { const n = [], r = new Set; let o; return po(t, i => { const s = i; Bu(s, n, [], r) && (o ||= [], o.push(s)) }), void 0 !== o && Cp(o, n), n } function Cp(e, t) { for (let n = 0; n < e.length; n++) { const { providers: o } = e[n]; Uu(o, i => { t.push(i) }) } } function Bu(e, t, n, r) { if (!(e = k(e))) return !1; let o = null, i = Xd(e); const s = !i && Y(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const u = e.ngModule; if (i = Xd(u), !i) return !1; o = u } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const u = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const c of u) Bu(c, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let c; r.add(o); try { po(i.imports, l => { Bu(l, t, n, r) && (c ||= [], c.push(l)) }) } finally { } void 0 !== c && Cp(c, t) } if (!a) { const c = Rn(o) || (() => new o); t.push({ provide: o, useFactory: c, deps: Q }, { provide: mp, useValue: o, multi: !0 }, { provide: So, useValue: () => R(o), multi: !0 }) } const u = i.providers; null == u || a || Uu(u, l => { t.push(l) }) } } return o !== e && void 0 !== e.providers } function Uu(e, t) { for (let n of e) $a(n) && (n = n.\u0275providers), Array.isArray(n) ? Uu(n, t) : t(n) } const Gb = X({ provide: String, useValue: X }); function zu(e) { return null !== e && "object" == typeof e && Gb in e } function kn(e) { return "function" == typeof e } const Gu = new I("Set Injector scope."), fs = {}, qb = {}; let Wu; function hs() { return void 0 === Wu && (Wu = new yp), Wu } class Xt { } class qu extends Xt { get destroyed() { return this._destroyed } constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Qu(t, s => this.processProvider(s)), this.records.set(gp, vr(void 0, this)), o.has("environment") && this.records.set(Xt, vr(void 0, this)); const i = this.records.get(Gu); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(mp.multi, Q, A.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const n of this._ngOnDestroyHooks) n.ngOnDestroy(); const t = this._onDestroyHooks; this._onDestroyHooks = []; for (const n of t) n() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear() } } onDestroy(t) { return this.assertNotDestroyed(), this._onDestroyHooks.push(t), () => this.removeOnDestroy(t) } runInContext(t) { this.assertNotDestroyed(); const n = pn(this), r = Ge(void 0); try { return t() } finally { pn(n), Ge(r) } } get(t, n = eo, r = A.Default) { if (this.assertNotDestroyed(), t.hasOwnProperty(uf)) return t[uf](this); r = Ti(r); const o = pn(this), i = Ge(void 0); try { if (!(r & A.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const u = function Jb(e) { return "function" == typeof e || "object" == typeof e && e instanceof I }(t) && Ii(t); a = u && this.injectableDefInScope(u) ? vr(Zu(t), fs) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & A.Self ? hs() : this.parent).get(t, n = r & A.Optional && n === eo ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[Mi] = s[Mi] || []).unshift(we(t)), o) throw s; return function Yw(e, t, n, r) { const o = e[Mi]; throw t[rf] && o.unshift(t[rf]), e.message = function Kw(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.slice(2) : e; let o = we(t); if (Array.isArray(t)) o = t.map(we).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : we(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(Gw, "\n  ")}` }("\n" + e.message, o, n, r), e.ngTokenPath = o, e[Mi] = null, e }(s, t, "R3InjectorError", this.source) } throw s } finally { Ge(i), pn(o) } } resolveInjectorInitializers() { const t = pn(this), n = Ge(void 0); try { const r = this.get(So.multi, Q, A.Self); for (const o of r) o() } finally { pn(t), Ge(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(we(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new C(205, !1) } processProvider(t) { let n = kn(t = k(t)) ? t : k(t && t.provide); const r = function Qb(e) { return zu(e) ? vr(void 0, e.useValue) : vr(function _p(e, t, n) { let r; if (kn(e)) { const o = k(e); return Rn(o) || Zu(o) } if (zu(e)) r = () => k(e.useValue); else if (function Ep(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...za(e.deps || [])); else if (function wp(e) { return !(!e || !e.useExisting) }(e)) r = () => R(k(e.useExisting)); else { const o = k(e && (e.useClass || e.provide)); if (!function Yb(e) { return !!e.deps }(e)) return Rn(o) || Zu(o); r = () => new o(...za(e.deps)) } return r }(e), fs) }(t); if (kn(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = vr(void 0, fs, !0), o.factory = () => za(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === fs && (n.value = qb, n.value = n.factory()), "object" == typeof n.value && n.value && function Kb(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = k(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } removeOnDestroy(t) { const n = this._onDestroyHooks.indexOf(t); -1 !== n && this._onDestroyHooks.splice(n, 1) } } function Zu(e) { const t = Ii(e), n = null !== t ? t.factory : Rn(e); if (null !== n) return n; if (e instanceof I) throw new C(204, !1); if (e instanceof Function) return function Zb(e) { const t = e.length; if (t > 0) throw function go(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new C(204, !1); const n = function Bw(e) { return e && (e[Si] || e[ef]) || null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new C(204, !1) } function vr(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function Qu(e, t) { for (const n of e) Array.isArray(n) ? Qu(n, t) : n && $a(n) ? Qu(n.\u0275providers, t) : t(n) } const ps = new I("AppId", { providedIn: "root", factory: () => Xb }), Xb = "ng", bp = new I("Platform Initializer"), Dr = new I("Platform ID", { providedIn: "platform", factory: () => "unknown" }), Ip = new I("CSP nonce", { providedIn: "root", factory: () => function wo() { if (void 0 !== ku) return ku; if (typeof document < "u") return document; throw new C(210, !1) }().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); let Mp = (e, t) => null; function Tp(e, t) { return Mp(e, t) } class uI { } class Rp { } class lI { resolveComponentFactory(t) { throw function cI(e) { const t = Error(`No component factory found for ${we(e)}.`); return t.ngComponent = e, t }(t) } } let Ds = (() => { class e { } return e.NULL = new lI, e })(); function dI() { return Cr(Re(), y()) } function Cr(e, t) { return new Dn(Qe(e, t)) } let Dn = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = dI, e })(); class Op { } let Cs = (() => { class e { constructor() { this.destroyNode = null } } return e.__NG_ELEMENT_ID__ = () => function hI() { const e = y(), n = rt(Re().index, e); return (nt(n) ? n : e)[$] }(), e })(), pI = (() => { class e { } return e.\u0275prov = x({ token: e, providedIn: "root", factory: () => null }), e })(); class ws { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const gI = new ws("16.1.2"), sc = {}; function No(e) { for (; e;) { e[V] |= 64; const t = vo(e); if (Ya(e) && !t) return e; e = t } return null } function ac(e) { return e.ngOriginalError } class Ln { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && ac(t); for (; n && ac(n);)n = ac(n); return n || null } } const kp = new I("", { providedIn: "root", factory: () => !1 }); function en(e) { return e instanceof Function ? e() : e } class Hp extends Mf { constructor() { super(...arguments), this.consumerAllowSignalWrites = !1, this._lView = null } set lView(t) { this._lView = t } onConsumerDependencyMayHaveChanged() { No(this._lView) } onProducerUpdateValueVersion() { } get hasReadASignal() { return this.hasProducers } runInContext(t, n, r) { const o = Te(this); this.trackingVersion++; try { t(n, r) } finally { Te(o) } } destroy() { this.trackingVersion++ } } let _s = null; function Bp() { return _s ??= new Hp, _s } function Up(e, t) { return e[t] ?? Bp() } function zp(e, t) { const n = Bp(); n.hasReadASignal && (e[t] = _s, n.lView = e, _s = new Hp) } const H = {}; function de(e) { Gp(Z(), y(), $e() + e, !1) } function Gp(e, t, n, r) { if (!r) if (3 == (3 & t[V])) { const i = e.preOrderCheckHooks; null !== i && Hi(t, i, n) } else { const i = e.preOrderHooks; null !== i && Bi(t, i, 0, n) } On(n) } function Qp(e, t = null, n = null, r) { const o = Yp(e, t, n, r); return o.resolveInjectorInitializers(), o } function Yp(e, t = null, n = null, r, o = new Set) { const i = [n || Q, zb(e)]; return r = r || ("object" == typeof e ? void 0 : we(e)), new qu(i, t || hs(), r || null, o) } let tn = (() => { class e { static create(n, r) { if (Array.isArray(n)) return Qp({ name: "" }, r, n, ""); { const o = n.name ?? ""; return Qp({ name: o }, n.parent, n.providers, o) } } } return e.THROW_IF_NOT_FOUND = eo, e.NULL = new yp, e.\u0275prov = x({ token: e, providedIn: "any", factory: () => R(gp) }), e.__NG_ELEMENT_ID__ = -1, e })(); function S(e, t = A.Default) { const n = y(); return null === n ? R(e, t) : dh(Re(), n, k(e), t) } function bs(e, t, n, r, o, i, s, a, u, c, l) { const d = t.blueprint.slice(); return d[Ee] = o, d[V] = 140 | r, (null !== c || e && 2048 & e[V]) && (d[V] |= 2048), Lf(d), d[ae] = d[tr] = e, d[ge] = n, d[An] = s || e && e[An], d[$] = a || e && e[$], d[er] = u || e && e[er] || null, d[Oe] = i, d[ao] = function W_() { return G_++ }(), d[Qt] = l, d[wf] = c, d[me] = 2 == t.type ? e[me] : d, d } function Er(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function uc(e, t, n, r, o) { const i = Gf(), s = nu(), u = e.data[t] = function kI(e, t, n, r, o, i) { let s = t ? t.injectorIndex : -1, a = 0; return function ir() { return null !== P.skipHydrationRootTNode }() && (a |= 128), { type: n, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = u), null !== i && (s ? null == i.child && null !== u.parent && (i.child = u) : null === i.next && (i.next = u, u.prev = i)), u }(e, t, n, r, o), function ZE() { return P.lFrame.inI18n }() && (i.flags |= 32); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function co() { const e = P.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return kt(i, !0), i } function Ro(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function Jp(e, t, n, r, o) { const i = Up(t, Ri), s = $e(), a = 2 & r; try { if (On(-1), a && t.length > q && Gp(e, t, q, !1), Ft(a ? 2 : 0, o), a) i.runInContext(n, r, o); else { const c = Te(null); try { n(r, o) } finally { Te(c) } } } finally { a && null === t[Ri] && zp(t, Ri), On(s), Ft(a ? 3 : 1, o) } } function cc(e, t, n) { if (Qa(t)) { const r = Te(null); try { const i = t.directiveEnd; for (let s = t.directiveStart; s < i; s++) { const a = e.data[s]; a.contentQueries && a.contentQueries(1, n[s], s) } } finally { Te(r) } } } function lc(e, t, n) { Bf() && (function UI(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; Nn(n) && function YI(e, t, n) { const r = Qe(t, e), o = Xp(n); let s = 16; n.signals ? s = 4096 : n.onPush && (s = 64); const a = Is(e, bs(e, o, null, s, r, t, null, e[An].rendererFactory.createRenderer(r, n), null, null, null)); e[t.index] = a }(t, n, e.data[o + n.componentOffset]), e.firstCreatePass || Wi(n, t), Fe(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const u = e.data[a], c = Pn(t, e, a, n); Fe(c, t), null !== s && KI(0, a - o, c, u, 0, s), Dt(u) && (rt(n.index, t)[ge] = Pn(t, e, a, n)) } }(e, t, n, Qe(n, t)), 64 == (64 & n.flags) && og(e, t, n)) } function dc(e, t, n = Qe) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } } function Xp(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = fc(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts, e.id) : t } function fc(e, t, n, r, o, i, s, a, u, c, l) { const d = q + r, f = d + o, h = function NI(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : H); return n }(d, f), p = "function" == typeof c ? c() : c; return h[E] = { type: e, blueprint: h, template: n, queries: null, viewQuery: a, declTNode: t, data: h.slice().fill(null, d), bindingStartIndex: d, expandoStartIndex: f, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: p, incompleteFirstPass: !1, ssrId: l } } let eg = e => null; function tg(e, t, n, r) { for (let o in e) if (e.hasOwnProperty(o)) { n = null === n ? {} : n; const i = e[o]; null === r ? ng(n, t, o, i) : r.hasOwnProperty(o) && ng(n, t, r[o], i) } return n } function ng(e, t, n, r) { e.hasOwnProperty(n) ? e[n].push(t, r) : e[n] = [t, r] } function it(e, t, n, r, o, i, s, a) { const u = Qe(t, n); let l, c = t.inputs; !a && null != c && (l = c[r]) ? (yc(e, n, l, r, o), Nn(t) && function VI(e, t) { const n = rt(t, e); 16 & n[V] || (n[V] |= 64) }(n, t.index)) : 3 & t.type && (r = function jI(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, i.setProperty(u, r, o)) } function hc(e, t, n, r) { if (Bf()) { const o = null === r ? null : { "": -1 }, i = function GI(e, t) { const n = e.directiveRegistry; let r = null, o = null; if (n) for (let i = 0; i < n.length; i++) { const s = n[i]; if (gf(t, s.selectors, !1)) if (r || (r = []), Dt(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s), pc(e, t, a.length) } else r.unshift(s), pc(e, t, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return null === r ? null : [r, o] }(e, n); let s, a; null === i ? s = a = null : [s, a] = i, null !== s && rg(e, t, n, s, o, a), o && function WI(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new C(-301, !1); r.push(t[o], i) } } }(n, r, o) } n.mergedAttrs = ro(n.mergedAttrs, n.attrs) } function rg(e, t, n, r, o, i) { for (let c = 0; c < r.length; c++)pu(Wi(n, t), e, r[c].type); !function ZI(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t }(n, e.data.length, r.length); for (let c = 0; c < r.length; c++) { const l = r[c]; l.providersResolver && l.providersResolver(l) } let s = !1, a = !1, u = Ro(e, t, r.length, null); for (let c = 0; c < r.length; c++) { const l = r[c]; n.mergedAttrs = ro(n.mergedAttrs, l.hostAttrs), QI(e, n, t, u, l), qI(u, l, o), null !== l.contentQueries && (n.flags |= 4), (null !== l.hostBindings || null !== l.hostAttrs || 0 !== l.hostVars) && (n.flags |= 64); const d = l.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ??= []).push(n.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ??= []).push(n.index), a = !0), u++ } !function LI(e, t, n) { const o = t.directiveEnd, i = e.data, s = t.attrs, a = []; let u = null, c = null; for (let l = t.directiveStart; l < o; l++) { const d = i[l], f = n ? n.get(d) : null, p = f ? f.outputs : null; u = tg(d.inputs, l, u, f ? f.inputs : null), c = tg(d.outputs, l, c, p); const g = null === u || null === s || pf(t) ? null : JI(u, l, s); a.push(g) } null !== u && (u.hasOwnProperty("class") && (t.flags |= 8), u.hasOwnProperty("style") && (t.flags |= 16)), t.initialInputs = a, t.inputs = u, t.outputs = c }(e, n, i) } function og(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function YE() { return P.lFrame.currentDirectiveIndex }(); try { On(i); for (let a = r; a < o; a++) { const u = e.data[a], c = t[a]; ou(a), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && zI(u, c) } } finally { On(-1), ou(s) } } function zI(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function pc(e, t, n) { t.componentOffset = n, (e.components ??= []).push(t.index) } function qI(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; Dt(t) && (n[""] = e) } } function QI(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = Rn(o.type)), s = new lo(i, Dt(o), S); e.blueprint[r] = s, n[r] = s, function HI(e, t, n, r, o) { const i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~t.index; (function BI(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(s) != a && s.push(a), s.push(n, r, i) } }(e, t, r, Ro(e, n, o.hostVars, H), o) } function jt(e, t, n, r, o, i) { const s = Qe(e, t); !function gc(e, t, n, r, o, i, s) { if (null == i) e.removeAttribute(t, o, n); else { const a = null == s ? L(i) : s(i, r || "", o); e.setAttribute(t, o, a, n) } }(t[$], s, i, e.value, n, r, o) } function KI(e, t, n, r, o, i) { const s = i[t]; if (null !== s) for (let a = 0; a < s.length;)ig(r, n, s[a++], s[a++], s[a++]) } function ig(e, t, n, r, o) { const i = Te(null); try { const s = e.inputTransforms; null !== s && s.hasOwnProperty(r) && (o = s[r].call(t, o)), null !== e.setInput ? e.setInput(t, o, n, r) : t[r] = o } finally { Te(i) } } function JI(e, t, n) { let r = null, o = 0; for (; o < n.length;) { const i = n[o]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; if (e.hasOwnProperty(i)) { null === r && (r = []); const s = e[i]; for (let a = 0; a < s.length; a += 2)if (s[a] === t) { r.push(i, s[a + 1], n[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return r } function sg(e, t, n, r) { return [e, !0, !1, t, null, 0, r, n, null, null, null] } function ag(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; su(n[r]), s.contentQueries(2, t[i], i) } } } function Is(e, t) { return e[io] ? e[Cf][vt] = t : e[io] = t, e[Cf] = t, t } function mc(e, t, n) { su(0); const r = Te(null); try { t(e, n) } finally { Te(r) } } function dg(e, t) { const n = e[er], r = n ? n.get(Ln, null) : null; r && r.handleError(t) } function yc(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++]; ig(e.data[s], t[s], r, a, o) } } function nn(e, t, n) { const r = function ji(e, t) { return se(t[e]) }(t, e); !function Bh(e, t, n) { e.setValue(t, n) }(e[$], r, n) } function XI(e, t) { const n = rt(t, e), r = n[E]; !function eS(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) }(r, n); const o = n[Ee]; null !== o && null === n[Qt] && (n[Qt] = Tp(o, n[er])), vc(r, n, n[ge]) } function vc(e, t, n) { au(t); try { const r = e.viewQuery; null !== r && mc(1, r, n); const o = e.template; null !== o && Jp(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && ag(e, t), e.staticViewQueries && mc(2, e.viewQuery, n); const i = e.components; null !== i && function tS(e, t) { for (let n = 0; n < t.length; n++)XI(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[V] &= -5, uu() } } let fg = (() => { class e { constructor() { this.all = new Set, this.queue = new Map } create(n, r, o) { const i = typeof Zone > "u" ? null : Zone.current, s = new SE(n, c => { this.all.has(c) && this.queue.set(c, i) }, o); let a; this.all.add(s), s.notify(); const u = () => { s.cleanup(), a?.(), this.all.delete(s), this.queue.delete(s) }; return a = r?.onDestroy(u), { destroy: u } } flush() { if (0 !== this.queue.size) for (const [n, r] of this.queue) this.queue.delete(n), r ? r.run(() => n.run()) : n.run() } get isQueueEmpty() { return 0 === this.queue.size } } return e.\u0275prov = x({ token: e, providedIn: "root", factory: () => new e }), e })(); function Ss(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = La(o, a) : 2 == i && (r = La(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function xo(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(se(i)), Ze(i)) { for (let a = Pe; a < i.length; a++) { const u = i[a], c = u[E].firstChild; null !== c && xo(u[E], u, c, r) } i[Ot] !== i[Ee] && r.push(i[Ot]) } const s = n.type; if (8 & s) xo(e, t, n.child, r); else if (32 & s) { const a = Mu(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = Jh(t, n); if (Array.isArray(a)) r.push(...a); else { const u = vo(t[me]); xo(u[E], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } function Ms(e, t, n, r = !0) { const o = t[An].rendererFactory; o.begin && o.begin(); try { hg(e, t, e.template, n) } catch (s) { throw r && dg(t, s), s } finally { o.end && o.end(), t[An].effectManager?.flush() } } function hg(e, t, n, r) { const o = t[V]; if (256 != (256 & o)) { t[An].effectManager?.flush(), au(t); try { Lf(t), function qf(e) { return P.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && Jp(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const c = e.preOrderCheckHooks; null !== c && Hi(t, c, null) } else { const c = e.preOrderHooks; null !== c && Bi(t, c, 0, null), cu(t, 0) } if (function sS(e) { for (let t = Vh(e); null !== t; t = $h(t)) { if (!t[Ef]) continue; const n = t[rr]; for (let r = 0; r < n.length; r++) { LE(n[r]) } } }(t), pg(t, 2), null !== e.contentQueries && ag(e, t), s) { const c = e.contentCheckHooks; null !== c && Hi(t, c) } else { const c = e.contentHooks; null !== c && Bi(t, c, 1), cu(t, 1) } !function AI(e, t) { const n = e.hostBindingOpCodes; if (null === n) return; const r = Up(t, xi); try { for (let o = 0; o < n.length; o++) { const i = n[o]; if (i < 0) On(~i); else { const s = i, a = n[++o], u = n[++o]; QE(a, s), r.runInContext(u, 2, t[s]) } } } finally { null === t[xi] && zp(t, xi), On(-1) } }(e, t); const a = e.components; null !== a && mg(t, a, 0); const u = e.viewQuery; if (null !== u && mc(2, u, r), s) { const c = e.viewCheckHooks; null !== c && Hi(t, c) } else { const c = e.viewHooks; null !== c && Bi(t, c, 2), cu(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[V] &= -73, jf(t) } finally { uu() } } } function pg(e, t) { for (let n = Vh(e); null !== n; n = $h(n))for (let r = Pe; r < n.length; r++)gg(n[r], t) } function aS(e, t, n) { gg(rt(t, e), n) } function gg(e, t) { if (!function FE(e) { return 128 == (128 & e[V]) }(e)) return; const n = e[E]; if (80 & e[V] && 0 === t || 1024 & e[V] || 2 === t) hg(n, e, n.template, e[ge]); else if (e[oo] > 0) { pg(e, 1); const o = e[E].components; null !== o && mg(e, o, 1) } } function mg(e, t, n) { for (let r = 0; r < t.length; r++)aS(e, t[r], n) } class Oo { get rootNodes() { const t = this._lView, n = t[E]; return xo(n, t, n.firstChild, []) } constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[ge] } set context(t) { this._lView[ge] = t } get destroyed() { return 256 == (256 & this._lView[V]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[ae]; if (Ze(t)) { const n = t[8], r = n ? n.indexOf(this) : -1; r > -1 && (Au(t, r), Qi(n, r)) } this._attachedToViewContainer = !1 } zh(this._lView[E], this._lView) } onDestroy(t) { !function $f(e, t) { if (256 == (256 & e[V])) throw new C(911, !1); null === e[gn] && (e[gn] = []), e[gn].push(t) }(this._lView, t) } markForCheck() { No(this._cdRefInjectingView || this._lView) } detach() { this._lView[V] &= -129 } reattach() { this._lView[V] |= 128 } detectChanges() { Ms(this._lView[E], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new C(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function sb(e, t) { Co(e, t, t[$], 2, null, null) }(this._lView[E], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new C(902, !1); this._appRef = t } } class uS extends Oo { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; Ms(t[E], t, t[ge], !1) } checkNoChanges() { } get context() { return null } } class yg extends Ds { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = Y(t); return new Po(n, this.ngModule) } } function vg(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class lS { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { r = Ti(r); const o = this.injector.get(t, sc, r); return o !== sc || n === sc ? o : this.parentInjector.get(t, n, r) } } class Po extends Rp { get inputs() { return vg(this.componentDef.inputs) } get outputs() { return vg(this.componentDef.outputs) } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function aE(e) { return e.map(sE).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof Xt ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new lS(t, i) : t, a = s.get(Op, null); if (null === a) throw new C(407, !1); const l = { rendererFactory: a, sanitizer: s.get(pI, null), effectManager: s.get(fg, null) }, d = a.createRenderer(null, this.componentDef), f = this.componentDef.selectors[0][0] || "div", h = r ? function RI(e, t, n, r) { const i = r.get(kp, !1) || n === et.ShadowDom, s = e.selectRootElement(t, i); return function xI(e) { eg(e) }(s), s }(d, r, this.componentDef.encapsulation, s) : is(d, f, function cS(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(f)), v = this.componentDef.signals ? 4608 : this.componentDef.onPush ? 576 : 528, D = fc(0, null, null, 1, 0, null, null, null, null, null, null), m = bs(null, D, null, v, null, null, l, d, s, null, null); let M, j; au(m); try { const U = this.componentDef; let Le, Ia = null; U.findHostDirectiveDefs ? (Le = [], Ia = new Map, U.findHostDirectiveDefs(U, Le, Ia), Le.push(U)) : Le = [U]; const IP = function fS(e, t) { const n = e[E], r = q; return e[r] = t, Er(n, r, 2, "#host", null) }(m, h), SP = function hS(e, t, n, r, o, i, s) { const a = o[E]; !function pS(e, t, n, r) { for (const o of e) t.mergedAttrs = ro(t.mergedAttrs, o.hostAttrs); null !== t.mergedAttrs && (Ss(t, t.mergedAttrs, !0), null !== n && np(r, n, t)) }(r, e, t, s); let u = null; null !== t && (u = Tp(t, o[er])); const c = i.rendererFactory.createRenderer(t, n); let l = 16; n.signals ? l = 4096 : n.onPush && (l = 64); const d = bs(o, Xp(n), null, l, o[e.index], e, i, c, null, null, u); return a.firstCreatePass && pc(a, e, r.length - 1), Is(o, d), o[e.index] = d }(IP, h, U, Le, m, l, d); j = kf(D, q), h && function mS(e, t, n, r) { if (r) qa(e, n, ["ng-version", gI.full]); else { const { attrs: o, classes: i } = function uE(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!yt(o)) break; o = i } r++ } return { attrs: t, classes: n } }(t.selectors[0]); o && qa(e, n, o), i && i.length > 0 && tp(e, n, i.join(" ")) } }(d, U, h, r), void 0 !== n && function yS(e, t, n) { const r = e.projection = []; for (let o = 0; o < t.length; o++) { const i = n[o]; r.push(null != i ? Array.from(i) : null) } }(j, this.ngContentSelectors, n), M = function gS(e, t, n, r, o, i) { const s = Re(), a = o[E], u = Qe(s, o); rg(a, o, s, n, null, r); for (let l = 0; l < n.length; l++)Fe(Pn(o, a, s.directiveStart + l, s), o); og(a, o, s), u && Fe(u, o); const c = Pn(o, a, s.directiveStart + s.componentOffset, s); if (e[ge] = o[ge] = c, null !== i) for (const l of i) l(c, t); return cc(a, s, e), c }(SP, U, Le, Ia, m, [vS]), vc(D, m, null) } finally { uu() } return new dS(this.componentType, M, Cr(j, m), m, j) } } class dS extends uI { constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.previousInputValues = null, this.instance = n, this.hostView = this.changeDetectorRef = new uS(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(t) && Object.is(this.previousInputValues.get(t), n)) return; const i = this._rootLView; yc(i[E], i, o, t, n), this.previousInputValues.set(t, n), No(rt(this._tNode.index, i)) } } get injector() { return new ur(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function vS() { const e = Re(); $i(y()[E], e) } function bg(e) { const t = e.inputConfig, n = {}; for (const r in t) if (t.hasOwnProperty(r)) { const o = t[r]; Array.isArray(o) && o[2] && (n[r] = o[2]) } e.inputTransforms = n } function As(e) { return !!function Dc(e) { return null !== e && ("function" == typeof e || "object" == typeof e) }(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function ke(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function Cc(e, t, n, r) { const o = y(); return ke(o, sr(), t) && (Z(), jt(ue(), o, e, t, n, r)), Cc } function br(e, t, n, r) { return ke(e, sr(), n) ? t + L(n) + r : H } function xr(e, t, n, r, o, i, s, a) { const u = y(), c = Z(), l = e + q, d = c.firstCreatePass ? function qS(e, t, n, r, o, i, s, a, u) { const c = t.consts, l = Er(t, e, 4, s || null, mn(c, a)); hc(t, n, l, mn(c, u)), $i(t, l); const d = l.tView = fc(2, l, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, c, null); return null !== t.queries && (t.queries.template(t, l), d.queries = t.queries.embeddedTView(l)), l }(l, c, u, t, n, r, o, i, s) : c.data[l]; kt(d, !1); const f = Lg(c, u, d, e); Vi() && as(c, u, f, d), Fe(f, u), Is(u, u[l] = sg(f, u, f, d)), Pi(d) && lc(c, u, d), null != s && dc(u, d, a) } let Lg = function jg(e, t, n, r) { return yn(!0), t[$].createComment("") }; function Vn(e, t, n) { const r = y(); return ke(r, sr(), t) && it(Z(), ue(), r, e, t, r[$], n, !1), Vn } function Sc(e, t, n, r, o) { const s = o ? "class" : "style"; yc(e, n, t.inputs[s], s, r) } function T(e, t, n, r) { const o = y(), i = Z(), s = q + e, a = o[$], u = i.firstCreatePass ? function JS(e, t, n, r, o, i) { const s = t.consts, u = Er(t, e, 2, r, mn(s, o)); return hc(t, n, u, mn(s, i)), null !== u.attrs && Ss(u, u.attrs, !1), null !== u.mergedAttrs && Ss(u, u.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, u), u }(s, i, o, t, n, r) : i.data[s], c = Vg(i, o, u, a, t, e); o[s] = c; const l = Pi(u); return kt(u, !0), np(a, c, u), 32 != (32 & u.flags) && Vi() && as(i, o, c, u), 0 === function VE() { return P.lFrame.elementDepthCount }() && Fe(c, o), function $E() { P.lFrame.elementDepthCount++ }(), l && (lc(i, o, u), cc(i, u, o)), null !== r && dc(o, u), T } function b() { let e = Re(); nu() ? function ru() { P.lFrame.isParent = !1 }() : (e = e.parent, kt(e, !1)); const t = e; (function BE(e) { return P.skipHydrationRootTNode === e })(t) && function WE() { P.skipHydrationRootTNode = null }(), function HE() { P.lFrame.elementDepthCount-- }(); const n = Z(); return n.firstCreatePass && ($i(n, e), Qa(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function a_(e) { return 0 != (8 & e.flags) }(t) && Sc(n, t, y(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function u_(e) { return 0 != (16 & e.flags) }(t) && Sc(n, t, y(), t.stylesWithoutHost, !1), b } function ne(e, t, n, r) { return T(e, t, n, r), b(), ne } let Vg = (e, t, n, r, o, i) => (yn(!0), is(r, o, function th() { return P.lFrame.currentNamespace }())); function Ps(e) { return !!e && "function" == typeof e.then } function Ug(e) { return !!e && "function" == typeof e.subscribe } function Vo(e, t, n, r) { const o = y(), i = Z(), s = Re(); return function Gg(e, t, n, r, o, i, s) { const a = Pi(r), c = e.firstCreatePass && function cg(e) { return e.cleanup || (e.cleanup = []) }(e), l = t[ge], d = function ug(e) { return e[Xn] || (e[Xn] = []) }(t); let f = !0; if (3 & r.type || s) { const g = Qe(r, t), v = s ? s(g) : g, D = d.length, m = s ? j => s(se(j[r.index])) : r.index; let M = null; if (!s && a && (M = function o0(e, t, n, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === n && o[i + 1] === r) { const a = t[Xn], u = o[i + 2]; return a.length > u ? a[u] : null } "string" == typeof s && (i += 2) } return null }(e, t, o, r.index)), null !== M) (M.__ngLastListenerFn__ || M).__ngNextListenerFn__ = i, M.__ngLastListenerFn__ = i, f = !1; else { i = qg(r, t, l, i, !1); const j = n.listen(v, o, i); d.push(i, j), c && c.push(o, m, D, D + 1) } } else i = qg(r, t, l, i, !1); const h = r.outputs; let p; if (f && null !== h && (p = h[o])) { const g = p.length; if (g) for (let v = 0; v < g; v += 2) { const U = t[p[v]][p[v + 1]].subscribe(i), Le = d.length; d.push(i, U), c && c.push(o, r.index, Le, -(Le + 1)) } } }(i, o, o[$], s, e, t, r), Vo } function Wg(e, t, n, r) { try { return Ft(6, t, n), !1 !== n(r) } catch (o) { return dg(e, o), !1 } finally { Ft(7, t, n) } } function qg(e, t, n, r, o) { return function i(s) { if (s === Function) return r; No(e.componentOffset > -1 ? rt(e.index, t) : t); let u = Wg(t, n, r, s), c = i.__ngNextListenerFn__; for (; c;)u = Wg(t, n, c, s) && u, c = c.__ngNextListenerFn__; return o && !1 === u && s.preventDefault(), u } } function $o(e = 1) { return function JE(e) { return (P.lFrame.contextLView = function XE(e, t) { for (; e > 0;)t = t[tr], e--; return t }(e, P.lFrame.contextLView))[ge] }(e) } function Ho(e, t, n) { return Fs(e, "", t, "", n), Ho } function Fs(e, t, n, r, o) { const i = y(), s = br(i, t, n, r); return s !== H && it(Z(), ue(), i, e, s, i[$], o, !1), Fs } function G(e, t = "") { const n = y(), r = Z(), o = e + q, i = r.firstCreatePass ? Er(r, o, 1, t, null) : r.data[o], s = ym(r, n, i, t, e); n[o] = s, Vi() && as(r, n, s, i), kt(i, !1) } let ym = (e, t, n, r, o) => (yn(!0), function os(e, t) { return e.createText(t) }(t[$], r)); function Hn(e) { return Bt("", e, ""), Hn } function Bt(e, t, n) { const r = y(), o = br(r, e, t, n); return o !== H && nn(r, $e(), o), Bt } const Fr = "en-US"; let Vm = Fr; class kr { } class dy { } class Vc extends kr { constructor(t, n, r) { super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new yg(this); const o = tt(t); this._bootstrapComponents = en(o.bootstrap), this._r3Injector = Yp(t, n, [{ provide: kr, useValue: this }, { provide: Ds, useValue: this.componentFactoryResolver }, ...r], we(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(t) } get injector() { return this._r3Injector } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class $c extends dy { constructor(t) { super(), this.moduleType = t } create(t) { return new Vc(this.moduleType, t, []) } } class fy extends kr { constructor(t) { super(), this.componentFactoryResolver = new yg(this), this.instance = null; const n = new qu([...t.providers, { provide: kr, useValue: this }, { provide: Ds, useValue: this.componentFactoryResolver }], t.parent || hs(), t.debugName, new Set(["environment"])); this.injector = n, t.runEnvironmentInitializers && n.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } } function Hc(e, t, n = null) { return new fy({ providers: e, parent: t, debugName: n, runEnvironmentInitializers: !0 }).injector } let eT = (() => { class e { constructor(n) { this._injector = n, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(n) { if (!n.standalone) return null; if (!this.cachedInjectors.has(n.id)) { const r = Dp(0, n.type), o = r.length > 0 ? Hc([r], this._injector, `Standalone[${n.type.name}]`) : null; this.cachedInjectors.set(n.id, o) } return this.cachedInjectors.get(n.id) } ngOnDestroy() { try { for (const n of this.cachedInjectors.values()) null !== n && n.destroy() } finally { this.cachedInjectors.clear() } } } return e.\u0275prov = x({ token: e, providedIn: "environment", factory: () => new e(R(Xt)) }), e })(); function hy(e) { e.getStandaloneInjector = t => t.get(eT).getOrCreateStandaloneInjector(e) } function Uc(e) { return t => { setTimeout(e, void 0, t) } } const Be = class ST extends Gt { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const u = t; o = u.next?.bind(u), i = u.error?.bind(u), s = u.complete?.bind(u) } this.__isAsync && (i = Uc(i), o && (o = Uc(o)), s && (s = Uc(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof at && t.add(a), a } }; let rn = (() => { class e { } return e.__NG_ELEMENT_ID__ = NT, e })(); const TT = rn, AT = class extends TT { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } get ssrId() { return this._declarationTContainer.tView?.ssrId || null } createEmbeddedView(t, n) { return this.createEmbeddedViewImpl(t, n, null) } createEmbeddedViewImpl(t, n, r) { const s = this._declarationTContainer.tView, a = bs(this._declarationLView, s, t, 4096 & this._declarationLView[V] ? 4096 : 16, null, s.declTNode, null, null, null, n || null, r || null); a[so] = this._declarationLView[this._declarationTContainer.index]; const c = this._declarationLView[xt]; return null !== c && (a[xt] = c.createEmbeddedView(s)), vc(s, a, t), new Oo(a) } }; function NT() { return function Bs(e, t) { return 4 & e.type ? new AT(t, e, Cr(e, t)) : null }(Re(), y()) } let Et = (() => { class e { } return e.__NG_ELEMENT_ID__ = LT, e })(); function LT() { return function Ny(e, t) { let n; const r = t[e.index]; return Ze(r) ? n = r : (n = sg(r, t, null, e), t[e.index] = n, Is(t, n)), Ry(n, t, e, r), new Ty(n, e, t) }(Re(), y()) } const jT = Et, Ty = class extends jT { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return Cr(this._hostTNode, this._hostLView) } get injector() { return new ur(this._hostTNode, this._hostLView) } get parentInjector() { const t = hu(this._hostTNode, this._hostLView); if (ih(t)) { const n = zi(t, this._hostLView), r = Ui(t); return new ur(n[E].data[r + 8], n) } return new ur(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = Ay(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - Pe } createEmbeddedView(t, n, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const a = t.createEmbeddedViewImpl(n || {}, i, null); return this.insertImpl(a, o, false), a } createComponent(t, n, r, o, i) { const s = t && !function ho(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const g = n || {}; a = g.index, r = g.injector, o = g.projectableNodes, i = g.environmentInjector || g.ngModuleRef } const u = s ? t : new Po(Y(t)), c = r || this.parentInjector; if (!i && null == u.ngModule) { const v = (s ? c : this.parentInjector).get(Xt, null); v && (i = v) } Y(u.componentType ?? {}); const h = u.create(c, o, null, i); return this.insertImpl(h.hostView, a, false), h } insert(t, n) { return this.insertImpl(t, n, !1) } insertImpl(t, n, r) { const o = t._lView, i = o[E]; if (function kE(e) { return Ze(e[ae]) }(o)) { const u = this.indexOf(t); if (-1 !== u) this.detach(u); else { const c = o[ae], l = new Ty(c, c[Oe], c[ae]); l.detach(l.indexOf(t)) } } const s = this._adjustIndex(n), a = this._lContainer; if (function ub(e, t, n, r) { const o = Pe + r, i = n.length; r > 0 && (n[o - 1][vt] = t), r < i - Pe ? (t[vt] = n[o], vh(n, Pe + r, t)) : (n.push(t), t[vt] = null), t[ae] = n; const s = t[so]; null !== s && n !== s && function cb(e, t) { const n = e[rr]; t[me] !== t[ae][ae][me] && (e[Ef] = !0), null === n ? e[rr] = [t] : n.push(t) }(s, t); const a = t[xt]; null !== a && a.insertView(e), t[V] |= 128 }(i, o, a, s), !r) { const u = Ou(s, a), c = o[$], l = ss(c, a[Ot]); null !== l && function ib(e, t, n, r, o, i) { r[Ee] = o, r[Oe] = t, Co(e, r, n, 1, o, i) }(i, a[Oe], c, o, l, u) } return t.attachToViewContainerRef(), vh(Wc(a), s, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = Ay(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = Au(this._lContainer, n); r && (Qi(Wc(this._lContainer), n), zh(r[E], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = Au(this._lContainer, n); return r && null != Qi(Wc(this._lContainer), n) ? new Oo(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function Ay(e) { return e[8] } function Wc(e) { return e[8] || (e[8] = []) } let Ry = function xy(e, t, n, r) { if (e[Ot]) return; let o; o = 8 & n.type ? se(r) : function VT(e, t) { const n = e[$], r = n.createComment(""), o = Qe(t, e); return Fn(n, ss(n, o), r, function hb(e, t) { return e.nextSibling(t) }(n, o), !1), r }(t, n), e[Ot] = o }; const rl = new I("Application Initializer"); let ol = (() => { class e { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((n, r) => { this.resolve = n, this.reject = r }), this.appInits = _(rl, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; const n = []; for (const o of this.appInits) { const i = o(); if (Ps(i)) n.push(i); else if (Ug(i)) { const s = new Promise((a, u) => { i.subscribe({ complete: a, error: u }) }); n.push(s) } } const r = () => { this.done = !0, this.resolve() }; Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), rv = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const on = new I("LocaleId", { providedIn: "root", factory: () => _(on, A.Optional | A.SkipSelf) || function mA() { return typeof $localize < "u" && $localize.locale || Fr }() }); let ov = (() => { class e { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new ut(!1) } add() { this.hasPendingTasks.next(!0); const n = this.taskId++; return this.pendingTasks.add(n), n } remove(n) { this.pendingTasks.delete(n), 0 === this.pendingTasks.size && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this.hasPendingTasks.next(!1) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); class vA { constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } } let iv = (() => { class e { compileModuleSync(n) { return new $c(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { const r = this.compileModuleSync(n), i = en(tt(n).declarations).reduce((s, a) => { const u = Y(a); return u && s.push(new Po(u)), s }, []); return new vA(r, i) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function uv(...e) { } class ce { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Be(!1), this.onMicrotaskEmpty = new Be(!1), this.onStable = new Be(!1), this.onError = new Be(!1), typeof Zone > "u") throw new C(908, !1); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function wA() { let e = oe.requestAnimationFrame, t = oe.cancelAnimationFrame; if (typeof Zone < "u" && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function bA(e) { const t = () => { !function _A(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(oe, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, sl(e), e.isCheckStableRunning = !0, il(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), sl(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return cv(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), lv(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return cv(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), lv(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, sl(e), il(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!ce.isInAngularZone()) throw new C(909, !1) } static assertNotInAngularZone() { if (ce.isInAngularZone()) throw new C(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, EA, uv, uv); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const EA = {}; function il(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function sl(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function cv(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function lv(e) { e._nesting--, il(e) } class IA { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Be, this.onMicrotaskEmpty = new Be, this.onStable = new Be, this.onError = new Be } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } const dv = new I("", { providedIn: "root", factory: fv }); function fv() { const e = _(ce); let t = !0; return function xw(...e) { const t = Xr(e), n = function Iw(e, t) { return "number" == typeof Fa(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? mt(r[0]) : Yn(n)(Ne(r, t)) : Mt }(new Ce(o => { t = e.isStable && !e.hasPendingMacrotasks && !e.hasPendingMicrotasks, e.runOutsideAngular(() => { o.next(t), o.complete() }) }), new Ce(o => { let i; e.runOutsideAngular(() => { i = e.onStable.subscribe(() => { ce.assertNotInAngularZone(), queueMicrotask(() => { !t && !e.hasPendingMacrotasks && !e.hasPendingMicrotasks && (t = !0, o.next(!0)) }) }) }); const s = e.onUnstable.subscribe(() => { ce.assertInAngularZone(), t && (t = !1, e.runOutsideAngular(() => { o.next(!1) })) }); return () => { i.unsubscribe(), s.unsubscribe() } }).pipe(Yd())) } const hv = new I(""), zs = new I(""); let cl, al = (() => { class e { constructor(n, r, o) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, cl || (function SA(e) { cl = e }(o), o.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { ce.assertNotInAngularZone(), queueMicrotask(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) queueMicrotask(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, o) { return [] } } return e.\u0275fac = function (n) { return new (n || e)(R(ce), R(ul), R(zs)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), ul = (() => { class e { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return cl?.findTestabilityInTree(this, n, r) ?? null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(), wn = null; const pv = new I("AllowMultipleToken"), ll = new I("PlatformDestroyListeners"), dl = new I("appBootstrapListener"); class mv { constructor(t, n) { this.name = t, this.token = n } } function vv(e, t, n = []) { const r = `Platform: ${t}`, o = new I(r); return (i = []) => { let s = fl(); if (!s || s.injector.get(pv, !1)) { const a = [...n, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function AA(e) { if (wn && !wn.get(pv, !1)) throw new C(400, !1); (function gv() { !function bE(e) { Tf = e }(() => { throw new C(600, !1) }) })(), wn = e; const t = e.get(Cv); (function yv(e) { e.get(bp, null)?.forEach(n => n()) })(e) }(function Dv(e = [], t) { return tn.create({ name: t, providers: [{ provide: Gu, useValue: "platform" }, { provide: ll, useValue: new Set([() => wn = null]) }, ...e] }) }(a, r)) } return function RA(e) { const t = fl(); if (!t) throw new C(401, !1); return t }() } } function fl() { return wn?.get(Cv) ?? null } let Cv = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const o = function xA(e = "zone.js", t) { return "noop" === e ? new IA : "zone.js" === e ? new ce(t) : e }(r?.ngZone, function wv(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: e?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: e?.runCoalescing ?? !1 } }({ eventCoalescing: r?.ngZoneEventCoalescing, runCoalescing: r?.ngZoneRunCoalescing })); return o.run(() => { const i = function XM(e, t, n) { return new Vc(e, t, n) }(n.moduleType, this.injector, function Sv(e) { return [{ provide: ce, useFactory: e }, { provide: So, multi: !0, useFactory: () => { const t = _(PA, { optional: !0 }); return () => t.initialize() } }, { provide: Iv, useFactory: OA }, { provide: dv, useFactory: fv }] }(() => o)), s = i.injector.get(Ln, null); return o.runOutsideAngular(() => { const a = o.onError.subscribe({ next: u => { s.handleError(u) } }); i.onDestroy(() => { Gs(this._modules, i), a.unsubscribe() }) }), function Ev(e, t, n) { try { const r = n(); return Ps(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(s, o, () => { const a = i.injector.get(ol); return a.runInitializers(), a.donePromise.then(() => (function $m(e) { ct(e, "Expected localeId to be defined"), "string" == typeof e && (Vm = e.toLowerCase().replace(/_/g, "-")) }(i.injector.get(on, Fr) || Fr), this._moduleDoBootstrap(i), i)) }) }) } bootstrapModule(n, r = []) { const o = _v({}, r); return function MA(e, t, n) { const r = new $c(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(Vr); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new C(-403, !1); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new C(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(ll, null); n && (n.forEach(r => r()), n.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)(R(tn)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function _v(e, t) { return Array.isArray(t) ? t.reduce(_v, e) : { ...e, ...t } } let Vr = (() => { class e { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = _(Iv), this.zoneIsStable = _(dv), this.componentTypes = [], this.components = [], this.isStable = _(ov).hasPendingTasks.pipe(Tt(n => n ? F(!1) : this.zoneIsStable), function Ow(e, t = ln) { return e = e ?? Pw, Se((n, r) => { let o, i = !0; n.subscribe(Me(r, s => { const a = t(s); (i || !e(o, a)) && (i = !1, o = a, r.next(s)) })) }) }(), Yd()), this._injector = _(Xt) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(n, r) { const o = n instanceof Rp; if (!this._injector.get(ol).done) throw !o && function Jn(e) { const t = Y(e) || xe(e) || qe(e); return null !== t && t.standalone }(n), new C(405, !1); let s; s = o ? n : this._injector.get(Ds).resolveComponentFactory(n), this.componentTypes.push(s.componentType); const a = function TA(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(kr), c = s.create(tn.NULL, [], r || s.selector, a), l = c.location.nativeElement, d = c.injector.get(hv, null); return d?.registerApplication(l), c.onDestroy(() => { this.detachView(c.hostView), Gs(this.components, c), d?.unregisterApplication(l) }), this._loadComponent(c), c } tick() { if (this._runningTick) throw new C(101, !1); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this.internalErrorHandler(n) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; Gs(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n); const r = this._injector.get(dl, []); r.push(...this._bootstrapListeners), r.forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => Gs(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new C(406, !1); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function Gs(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const Iv = new I("", { providedIn: "root", factory: () => _(Ln).handleError.bind(void 0) }); function OA() { const e = _(ce), t = _(Ln); return n => e.runOutsideAngular(() => t.handleError(n)) } let PA = (() => { class e { constructor() { this.zone = _(ce), this.applicationRef = _(Vr) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); let hl = (() => { class e { } return e.__NG_ELEMENT_ID__ = kA, e })(); function kA(e) { return function LA(e, t, n) { if (Nn(e) && !n) { const r = rt(e.index, t); return new Oo(r, r) } return 47 & e.type ? new Oo(t[me], t) : null }(Re(), y(), 16 == (16 & e)) } class Nv { constructor() { } supports(t) { return As(t) } create(t) { return new UA(t) } } const BA = (e, t) => t; class UA { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || BA } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < xv(r, o, i) ? n : r, a = xv(s, o, i), u = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const c = a - o, l = u - o; if (c != l) { for (let f = 0; f < c; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; l <= p && p < c && (i[f] = h + 1) } i[s.previousIndex] = l - c } } a !== u && t(s, a, u) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !As(t)) throw new C(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function AS(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Symbol.iterator](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new zA(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new Rv), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Rv), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class zA { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class GA { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class Rv { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new GA, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function xv(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } function Pv() { return new Zs([new Nv]) } let Zs = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || Pv()), deps: [[e, new Ji, new Ki]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new C(901, !1) } } return e.\u0275prov = x({ token: e, providedIn: "root", factory: Pv }), e })(); const YA = vv(null, "core", []); let KA = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)(R(Vr)) }, e.\u0275mod = Tn({ type: e }), e.\u0275inj = hn({}), e })(); function Cl(e) { return "boolean" == typeof e ? e : null != e && "false" !== e } let wl = null; function $r() { return wl } class cN { } const ft = new I("DocumentToken"); let El = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return _(dN) }, providedIn: "platform" }), e })(); const lN = new I("Location Initialized"); let dN = (() => { class e extends El { constructor() { super(), this._doc = _(ft), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return $r().getBaseHref(this._doc) } onPopState(n) { const r = $r().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { const r = $r().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(n) { this._location.pathname = n } pushState(n, r, o) { this._history.pushState(n, r, o) } replaceState(n, r, o) { this._history.replaceState(n, r, o) } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return new e }, providedIn: "platform" }), e })(); function _l(e, t) { if (0 == e.length) return t; if (0 == t.length) return e; let n = 0; return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t } function Bv(e) { const t = e.match(/#|\?|$/), n = t && t.index || e.length; return e.slice(0, n - ("/" === e[n - 1] ? 1 : 0)) + e.slice(n) } function sn(e) { return e && "?" !== e[0] ? "?" + e : e } let zn = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return _(zv) }, providedIn: "root" }), e })(); const Uv = new I("appBaseHref"); let zv = (() => { class e extends zn { constructor(n, r) { super(), this._platformLocation = n, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? _(ft).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return _l(this._baseHref, n) } path(n = !1) { const r = this._platformLocation.pathname + sn(this._platformLocation.search), o = this._platformLocation.hash; return o && n ? `${r}${o}` : r } pushState(n, r, o, i) { const s = this.prepareExternalUrl(o + sn(i)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { const s = this.prepareExternalUrl(o + sn(i)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } } return e.\u0275fac = function (n) { return new (n || e)(R(El), R(Uv, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), fN = (() => { class e extends zn { constructor(n, r) { super(), this._platformLocation = n, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } path(n = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(n) { const r = _l(this._baseHref, n); return r.length > 0 ? "#" + r : r } pushState(n, r, o, i) { let s = this.prepareExternalUrl(o + sn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { let s = this.prepareExternalUrl(o + sn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } } return e.\u0275fac = function (n) { return new (n || e)(R(El), R(Uv, 8)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(), bl = (() => { class e { constructor(n) { this._subject = new Be, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = n; const r = this._locationStrategy.getBaseHref(); this._basePath = function gN(e) { if (new RegExp("^(https?:)?//").test(e)) { const [, n] = e.split(/\/\/[^\/]+/); return n } return e }(Bv(Gv(r))), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(n = !1) { return this.normalize(this._locationStrategy.path(n)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + sn(r)) } normalize(n) { return e.stripTrailingSlash(function pN(e, t) { if (!e || !t.startsWith(e)) return t; const n = t.substring(e.length); return "" === n || ["/", ";", "?", "#"].includes(n[0]) ? n : t }(this._basePath, Gv(n))) } prepareExternalUrl(n) { return n && "/" !== n[0] && (n = "/" + n), this._locationStrategy.prepareExternalUrl(n) } go(n, r = "", o = null) { this._locationStrategy.pushState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + sn(r)), o) } replaceState(n, r = "", o = null) { this._locationStrategy.replaceState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + sn(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(n = 0) { this._locationStrategy.historyGo?.(n) } onUrlChange(n) { return this._urlChangeListeners.push(n), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })), () => { const r = this._urlChangeListeners.indexOf(n); this._urlChangeListeners.splice(r, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(o => o(n, r)) } subscribe(n, r, o) { return this._subject.subscribe({ next: n, error: r, complete: o }) } } return e.normalizeQueryParams = sn, e.joinWithSlash = _l, e.stripTrailingSlash = Bv, e.\u0275fac = function (n) { return new (n || e)(R(zn)) }, e.\u0275prov = x({ token: e, factory: function () { return function hN() { return new bl(R(zn)) }() }, providedIn: "root" }), e })(); function Gv(e) { return e.replace(/\/index.html$/, "") } class tR { constructor(t, n, r, o) { this.$implicit = t, this.ngForOf = n, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Fl = (() => { class e { set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } constructor(n, r, o) { this._viewContainer = n, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = this._viewContainer; n.forEachOperation((o, i, s) => { if (null == o.previousIndex) r.createEmbeddedView(this._template, new tR(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === i ? void 0 : i); else if (null !== i) { const a = r.get(i); r.move(a, s), nD(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { const a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } n.forEachIdentityChange(o => { nD(r.get(o.currentIndex), o) }) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(S(Et), S(rn), S(Zs)) }, e.\u0275dir = je({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), e })(); function nD(e, t) { e.context.$implicit = t.item } let kl = (() => { class e { constructor(n, r) { this._viewContainer = n, this._context = new nR, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { rD("ngIfThen", n), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { rD("ngIfElse", n), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(S(Et), S(rn)) }, e.\u0275dir = je({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }), e })(); class nR { constructor() { this.$implicit = null, this.ngIf = null } } function rD(e, t) { if (t && !t.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${we(t)}'.`) } let MR = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Tn({ type: e }), e.\u0275inj = hn({}), e })(); function aD(e) { return "server" === e } let RR = (() => { class e { } return e.\u0275prov = x({ token: e, providedIn: "root", factory: () => new xR(R(ft), window) }), e })(); class xR { constructor(t, n) { this.document = t, this.window = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const n = function OR(e, t) { const n = e.getElementById(t) || e.getElementsByName(t)[0]; if (n) return n; if ("function" == typeof e.createTreeWalker && e.body && "function" == typeof e.body.attachShadow) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let o = r.currentNode; for (; o;) { const i = o.shadowRoot; if (i) { const s = i.getElementById(t) || i.querySelector(`[name="${t}"]`); if (s) return s } o = r.nextNode() } } return null }(this.document, t); n && (this.scrollToElement(n), n.focus()) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const n = this.window.history; n && n.scrollRestoration && (n.scrollRestoration = t) } } scrollToElement(t) { const n = t.getBoundingClientRect(), r = n.left + this.window.pageXOffset, o = n.top + this.window.pageYOffset, i = this.offset(); this.window.scrollTo(r - i[0], o - i[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = uD(this.window.history) || uD(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } function uD(e) { return Object.getOwnPropertyDescriptor(e, "scrollRestoration") } class rx extends cN { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class Ul extends rx { static makeCurrent() { !function uN(e) { wl || (wl = e) }(new Ul) } onAndCancel(t, n, r) { return t.addEventListener(n, r), () => { t.removeEventListener(n, r) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function ox() { return ti = ti || document.querySelector("base"), ti ? ti.getAttribute("href") : null }(); return null == n ? null : function ix(e) { aa = aa || document.createElement("a"), aa.setAttribute("href", e); const t = aa.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { ti = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function JN(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null }(document.cookie, t) } } let aa, ti = null, ax = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const zl = new I("EventManagerPlugins"); let hD = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => { o.manager = this }), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { let r = this._eventNameToPlugin.get(n); if (r) return r; if (r = this._plugins.find(i => i.supports(n)), !r) throw new C(5101, !1); return this._eventNameToPlugin.set(n, r), r } } return e.\u0275fac = function (n) { return new (n || e)(R(zl), R(ce)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); class pD { constructor(t) { this._doc = t } } const Gl = "ng-app-id"; let gD = (() => { class e { constructor(n, r, o, i = {}) { this.doc = n, this.appId = r, this.nonce = o, this.platformId = i, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = aD(i), this.resetHostNodes() } addStyles(n) { for (const r of n) 1 === this.changeUsageCount(r, 1) && this.onStyleAdded(r) } removeStyles(n) { for (const r of n) this.changeUsageCount(r, -1) <= 0 && this.onStyleRemoved(r) } ngOnDestroy() { const n = this.styleNodesInDOM; n && (n.forEach(r => r.remove()), n.clear()); for (const r of this.getAllStyles()) this.onStyleRemoved(r); this.resetHostNodes() } addHost(n) { this.hostNodes.add(n); for (const r of this.getAllStyles()) this.addStyleToHost(n, r) } removeHost(n) { this.hostNodes.delete(n) } getAllStyles() { return this.styleRef.keys() } onStyleAdded(n) { for (const r of this.hostNodes) this.addStyleToHost(r, n) } onStyleRemoved(n) { const r = this.styleRef; r.get(n)?.elements?.forEach(o => o.remove()), r.delete(n) } collectServerRenderedStyles() { const n = this.doc.head?.querySelectorAll(`style[${Gl}="${this.appId}"]`); if (n?.length) { const r = new Map; return n.forEach(o => { null != o.textContent && r.set(o.textContent, o) }), r } return null } changeUsageCount(n, r) { const o = this.styleRef; if (o.has(n)) { const i = o.get(n); return i.usage += r, i.usage } return o.set(n, { usage: r, elements: [] }), r } getStyleElement(n, r) { const o = this.styleNodesInDOM, i = o?.get(r); if (i?.parentNode === n) return o.delete(r), i.removeAttribute(Gl), i; { const s = this.doc.createElement("style"); return this.nonce && s.setAttribute("nonce", this.nonce), s.textContent = r, this.platformIsServer && s.setAttribute(Gl, this.appId), s } } addStyleToHost(n, r) { const o = this.getStyleElement(n, r); n.appendChild(o); const i = this.styleRef, s = i.get(r)?.elements; s ? s.push(o) : i.set(r, { elements: [o], usage: 1 }) } resetHostNodes() { const n = this.hostNodes; n.clear(), n.add(this.doc.head) } } return e.\u0275fac = function (n) { return new (n || e)(R(ft), R(ps), R(Ip, 8), R(Dr)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const Wl = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, ql = /%COMP%/g, dx = new I("RemoveStylesOnCompDestory", { providedIn: "root", factory: () => !1 }); function yD(e, t) { return t.map(n => n.replace(ql, e)) } let vD = (() => { class e { constructor(n, r, o, i, s, a, u, c = null) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestory = i, this.doc = s, this.platformId = a, this.ngZone = u, this.nonce = c, this.rendererByCompId = new Map, this.platformIsServer = aD(a), this.defaultRenderer = new Zl(n, s, u, this.platformIsServer) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; this.platformIsServer && r.encapsulation === et.ShadowDom && (r = { ...r, encapsulation: et.Emulated }); const o = this.getOrCreateRenderer(n, r); return o instanceof CD ? o.applyToHost(n) : o instanceof Ql && o.applyStyles(), o } getOrCreateRenderer(n, r) { const o = this.rendererByCompId; let i = o.get(r.id); if (!i) { const s = this.doc, a = this.ngZone, u = this.eventManager, c = this.sharedStylesHost, l = this.removeStylesOnCompDestory, d = this.platformIsServer; switch (r.encapsulation) { case et.Emulated: i = new CD(u, c, r, this.appId, l, s, a, d); break; case et.ShadowDom: return new gx(u, c, n, r, s, a, this.nonce, d); default: i = new Ql(u, c, r, l, s, a, d) }i.onDestroy = () => o.delete(r.id), o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } } return e.\u0275fac = function (n) { return new (n || e)(R(hD), R(gD), R(ps), R(dx), R(ft), R(Dr), R(ce), R(Ip)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); class Zl { constructor(t, n, r, o) { this.eventManager = t, this.doc = n, this.ngZone = r, this.platformIsServer = o, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? this.doc.createElementNS(Wl[n] || n, t) : this.doc.createElement(t) } createComment(t) { return this.doc.createComment(t) } createText(t) { return this.doc.createTextNode(t) } appendChild(t, n) { (DD(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (DD(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? this.doc.querySelector(t) : t; if (!r) throw new C(5104, !1); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = Wl[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = Wl[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (Ye.DashCase | Ye.Important) ? t.style.setProperty(n, r, o & Ye.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & Ye.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { if ("string" == typeof t && !(t = $r().getGlobalEventTarget(this.doc, t))) throw new Error(`Unsupported event target ${t} for event ${n}`); return this.eventManager.addEventListener(t, n, this.decoratePreventDefault(r)) } decoratePreventDefault(t) { return n => { if ("__ngUnwrap__" === n) return t; !1 === (this.platformIsServer ? this.ngZone.runGuarded(() => t(n)) : t(n)) && n.preventDefault() } } } function DD(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class gx extends Zl { constructor(t, n, r, o, i, s, a, u) { super(t, i, s, u), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const c = yD(o.id, o.styles); for (const l of c) { const d = document.createElement("style"); a && d.setAttribute("nonce", a), d.textContent = l, this.shadowRoot.appendChild(d) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class Ql extends Zl { constructor(t, n, r, o, i, s, a, u) { super(t, i, s, a), this.sharedStylesHost = n, this.removeStylesOnCompDestory = o, this.rendererUsageCount = 0, this.styles = u ? yD(u, r.styles) : r.styles } applyStyles() { this.sharedStylesHost.addStyles(this.styles), this.rendererUsageCount++ } destroy() { this.removeStylesOnCompDestory && (this.sharedStylesHost.removeStyles(this.styles), this.rendererUsageCount--, 0 === this.rendererUsageCount && this.onDestroy?.()) } } class CD extends Ql { constructor(t, n, r, o, i, s, a, u) { const c = o + "-" + r.id; super(t, n, r, i, s, a, u, c), this.contentAttr = function fx(e) { return "_ngcontent-%COMP%".replace(ql, e) }(c), this.hostAttr = function hx(e) { return "_nghost-%COMP%".replace(ql, e) }(c) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } let mx = (() => { class e extends pD { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } } return e.\u0275fac = function (n) { return new (n || e)(R(ft)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const wD = ["alt", "control", "meta", "shift"], yx = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, vx = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let Dx = (() => { class e extends pD { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => $r().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), wD.forEach(c => { const l = r.indexOf(c); l > -1 && (r.splice(l, 1), s += c + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const u = {}; return u.domEventName = o, u.fullKey = s, u } static matchEventFullKeyCode(n, r) { let o = yx[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), wD.forEach(s => { s !== o && (0, vx[s])(n) && (i += s + ".") }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)(R(ft)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); const _x = vv(YA, "browser", [{ provide: Dr, useValue: "browser" }, { provide: bp, useValue: function Cx() { Ul.makeCurrent() }, multi: !0 }, { provide: ft, useFactory: function Ex() { return function wb(e) { ku = e }(document), document }, deps: [] }]), bx = new I(""), bD = [{ provide: zs, useClass: class sx { addToWindow(t) { oe.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new C(5103, !1); return i }, oe.getAllAngularTestabilities = () => t.getAllTestabilities(), oe.getAllAngularRootElements = () => t.getAllRootElements(), oe.frameworkStabilizers || (oe.frameworkStabilizers = []), oe.frameworkStabilizers.push(r => { const o = oe.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (u) { s = s || u, i--, 0 == i && r(s) }; o.forEach(function (u) { u.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { return null == n ? null : t.getTestability(n) ?? (r ? $r().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null) } }, deps: [] }, { provide: hv, useClass: al, deps: [ce, ul, zs] }, { provide: al, useClass: al, deps: [ce, ul, zs] }], ID = [{ provide: Gu, useValue: "root" }, { provide: Ln, useFactory: function wx() { return new Ln }, deps: [] }, { provide: zl, useClass: mx, multi: !0, deps: [ft, ce, Dr] }, { provide: zl, useClass: Dx, multi: !0, deps: [ft] }, vD, gD, hD, { provide: Op, useExisting: vD }, { provide: class PR { }, useClass: ax, deps: [] }, []]; let Ix = (() => { class e { constructor(n) { } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: ps, useValue: n.appId }] } } } return e.\u0275fac = function (n) { return new (n || e)(R(bx, 12)) }, e.\u0275mod = Tn({ type: e }), e.\u0275inj = hn({ providers: [...ID, ...bD], imports: [MR, KA] }), e })(), SD = (() => { class e { constructor(n) { this._doc = n } getTitle() { return this._doc.title } setTitle(n) { this._doc.title = n || "" } } return e.\u0275fac = function (n) { return new (n || e)(R(ft)) }, e.\u0275prov = x({ token: e, factory: function (n) { let r = null; return r = n ? new n : function Mx() { return new SD(R(ft)) }(), r }, providedIn: "root" }), e })(); typeof window < "u" && window; const { isArray: Ox } = Array, { getPrototypeOf: Px, prototype: Fx, keys: kx } = Object; const { isArray: Vx } = Array; function Kl(...e) { const t = Xr(e), n = function bw(e) { return te(Fa(e)) ? e.pop() : void 0 }(e), { args: r, keys: o } = function Lx(e) { if (1 === e.length) { const t = e[0]; if (Ox(t)) return { args: t, keys: null }; if (function jx(e) { return e && "object" == typeof e && Px(e) === Fx }(t)) { const n = kx(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } }(e); if (0 === r.length) return Ne([], t); const i = new Ce(function Ux(e, t, n = ln) { return r => { ND(t, () => { const { length: o } = e, i = new Array(o); let s = o, a = o; for (let u = 0; u < o; u++)ND(t, () => { const c = Ne(e[u], t); let l = !1; c.subscribe(Me(r, d => { i[u] = d, l || (l = !0, a--), a || r.next(n(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, t, o ? s => function Bx(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) }(o, s) : ln)); return n ? i.pipe(function Hx(e) { return re(t => function $x(e, t) { return Vx(t) ? e(...t) : e(t) }(e, t)) }(n)) : i } function ND(e, t, n) { e ? Wt(n, e, t) : t() } const ua = Yr(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function Jl(...e) { return function zx() { return Yn(1) }()(Ne(e, Xr(e))) } function RD(e) { return new Ce(t => { mt(e()).subscribe(t) }) } function ni(e, t) { const n = te(e) ? e : () => e, r = o => o.error(n()); return new Ce(t ? o => t.schedule(r, 0, o) : r) } function Xl() { return Se((e, t) => { let n = null; e._refCount++; const r = Me(t, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (n = null); const o = e._connection, i = n; n = null, o && (!i || o === i) && o.unsubscribe(), t.unsubscribe() }); e.subscribe(r), r.closed || (n = e.connect()) }) } class xD extends Ce { constructor(t, n) { super(), this.source = t, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, xd(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, t?.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new at; const n = this.getSubject(); t.add(this.source.subscribe(Me(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), t.closed && (this._connection = null, t = at.EMPTY) } return t } refCount() { return Xl()(this) } } function Hr(e) { return e <= 0 ? () => Mt : Se((t, n) => { let r = 0; t.subscribe(Me(n, o => { ++r <= e && (n.next(o), e <= r && n.complete()) })) }) } function _n(e, t) { return Se((n, r) => { let o = 0; n.subscribe(Me(r, i => e.call(t, i, o++) && r.next(i))) }) } function ca(e) { return Se((t, n) => { let r = !1; t.subscribe(Me(n, o => { r = !0, n.next(o) }, () => { r || n.next(e), n.complete() })) }) } function OD(e = Wx) { return Se((t, n) => { let r = !1; t.subscribe(Me(n, o => { r = !0, n.next(o) }, () => r ? n.complete() : n.error(e()))) }) } function Wx() { return new ua } function Gn(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? _n((o, i) => e(o, i, r)) : ln, Hr(1), n ? ca(t) : OD(() => new ua)) } function ri(e, t) { return te(t) ? Ae(e, t, 1) : Ae(e, 1) } function ze(e, t, n) { const r = te(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? Se((o, i) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; o.subscribe(Me(i, u => { var c; null === (c = r.next) || void 0 === c || c.call(r, u), i.next(u) }, () => { var u; a = !1, null === (u = r.complete) || void 0 === u || u.call(r), i.complete() }, u => { var c; a = !1, null === (c = r.error) || void 0 === c || c.call(r, u), i.error(u) }, () => { var u, c; a && (null === (u = r.unsubscribe) || void 0 === u || u.call(r)), null === (c = r.finalize) || void 0 === c || c.call(r) })) }) : ln } function Wn(e) { return Se((t, n) => { let i, r = null, o = !1; r = t.subscribe(Me(n, void 0, void 0, s => { i = mt(e(s, Wn(e)(t))), r ? (r.unsubscribe(), r = null, i.subscribe(n)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(n)) }) } function ed(e) { return e <= 0 ? () => Mt : Se((t, n) => { let r = []; t.subscribe(Me(n, o => { r.push(o), e < r.length && r.shift() }, () => { for (const o of r) n.next(o); n.complete() }, void 0, () => { r = null })) }) } function td(e) { return Se((t, n) => { try { t.subscribe(n) } finally { n.add(e) } }) } const B = "primary", oi = Symbol("RouteTitle"); class Kx { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n[0] : n } return null } getAll(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } } function Br(e) { return new Kx(e) } function Jx(e, t, n) { const r = n.path.split("/"); if (r.length > e.length || "full" === n.pathMatch && (t.hasChildren() || r.length < e.length)) return null; const o = {}; for (let i = 0; i < r.length; i++) { const s = r[i], a = e[i]; if (s.startsWith(":")) o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function Ut(e, t) { const n = e ? Object.keys(e) : void 0, r = t ? Object.keys(t) : void 0; if (!n || !r || n.length != r.length) return !1; let o; for (let i = 0; i < n.length; i++)if (o = n[i], !PD(e[o], t[o])) return !1; return !0 } function PD(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; const n = [...e].sort(), r = [...t].sort(); return n.every((o, i) => r[i] === o) } return e === t } function FD(e) { return e.length > 0 ? e[e.length - 1] : null } function bn(e) { return function xx(e) { return !!e && (e instanceof Ce || te(e.lift) && te(e.subscribe)) }(e) ? e : Ps(e) ? Ne(Promise.resolve(e)) : F(e) } const e1 = { exact: function jD(e, t, n) { if (!qn(e.segments, t.segments) || !la(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren) return !1; for (const r in t.children) if (!e.children[r] || !jD(e.children[r], t.children[r], n)) return !1; return !0 }, subset: VD }, kD = { exact: function t1(e, t) { return Ut(e, t) }, subset: function n1(e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => PD(e[n], t[n])) }, ignored: () => !0 }; function LD(e, t, n) { return e1[n.paths](e.root, t.root, n.matrixParams) && kD[n.queryParams](e.queryParams, t.queryParams) && !("exact" === n.fragment && e.fragment !== t.fragment) } function VD(e, t, n) { return $D(e, t, t.segments, n) } function $D(e, t, n, r) { if (e.segments.length > n.length) { const o = e.segments.slice(0, n.length); return !(!qn(o, n) || t.hasChildren() || !la(o, n, r)) } if (e.segments.length === n.length) { if (!qn(e.segments, n) || !la(e.segments, n, r)) return !1; for (const o in t.children) if (!e.children[o] || !VD(e.children[o], t.children[o], r)) return !1; return !0 } { const o = n.slice(0, e.segments.length), i = n.slice(e.segments.length); return !!(qn(e.segments, o) && la(e.segments, o, r) && e.children[B]) && $D(e.children[B], t, i, r) } } function la(e, t, n) { return t.every((r, o) => kD[n](e[o].parameters, r.parameters)) } class Ur { constructor(t = new ee([], {}), n = {}, r = null) { this.root = t, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Br(this.queryParams)), this._queryParamMap } toString() { return i1.serialize(this) } } class ee { constructor(t, n) { this.segments = t, this.children = n, this.parent = null, Object.values(n).forEach(r => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return da(this) } } class ii { constructor(t, n) { this.path = t, this.parameters = n } get parameterMap() { return this._parameterMap || (this._parameterMap = Br(this.parameters)), this._parameterMap } toString() { return UD(this) } } function qn(e, t) { return e.length === t.length && e.every((n, r) => n.path === t[r].path) } let si = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return new nd }, providedIn: "root" }), e })(); class nd { parse(t) { const n = new m1(t); return new Ur(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(t) { const n = `/${ai(t.root, !0)}`, r = function u1(e) { const t = Object.keys(e).map(n => { const r = e[n]; return Array.isArray(r) ? r.map(o => `${fa(n)}=${fa(o)}`).join("&") : `${fa(n)}=${fa(r)}` }).filter(n => !!n); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); return `${n}${r}${"string" == typeof t.fragment ? `#${function s1(e) { return encodeURI(e) }(t.fragment)}` : ""}` } } const i1 = new nd; function da(e) { return e.segments.map(t => UD(t)).join("/") } function ai(e, t) { if (!e.hasChildren()) return da(e); if (t) { const n = e.children[B] ? ai(e.children[B], !1) : "", r = []; return Object.entries(e.children).forEach(([o, i]) => { o !== B && r.push(`${o}:${ai(i, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = function o1(e, t) { let n = []; return Object.entries(e.children).forEach(([r, o]) => { r === B && (n = n.concat(t(o, r))) }), Object.entries(e.children).forEach(([r, o]) => { r !== B && (n = n.concat(t(o, r))) }), n }(e, (r, o) => o === B ? [ai(e.children[B], !1)] : [`${o}:${ai(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[B] ? `${da(e)}/${n[0]}` : `${da(e)}/(${n.join("//")})` } } function HD(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function fa(e) { return HD(e).replace(/%3B/gi, ";") } function rd(e) { return HD(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function ha(e) { return decodeURIComponent(e) } function BD(e) { return ha(e.replace(/\+/g, "%20")) } function UD(e) { return `${rd(e.path)}${function a1(e) { return Object.keys(e).map(t => `;${rd(t)}=${rd(e[t])}`).join("") }(e.parameters)}` } const c1 = /^[^\/()?;#]+/; function od(e) { const t = e.match(c1); return t ? t[0] : "" } const l1 = /^[^\/()?;=#]+/, f1 = /^[^=?&#]+/, p1 = /^[^&#]+/; class m1 { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new ee([], {}) : new ee([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (t.length > 0 || Object.keys(n).length > 0) && (r[B] = new ee(t, n)), r } parseSegment() { const t = od(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new C(4009, !1); return this.capture(t), new ii(ha(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const n = function d1(e) { const t = e.match(l1); return t ? t[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const o = od(this.remaining); o && (r = o, this.capture(r)) } t[ha(n)] = ha(r) } parseQueryParam(t) { const n = function h1(e) { const t = e.match(f1); return t ? t[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const s = function g1(e) { const t = e.match(p1); return t ? t[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const o = BD(n), i = BD(r); if (t.hasOwnProperty(o)) { let s = t[o]; Array.isArray(s) || (s = [s], t[o] = s), s.push(i) } else t[o] = i } parseParens(t) { const n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = od(this.remaining), o = this.remaining[r.length]; if ("/" !== o && ")" !== o && ";" !== o) throw new C(4010, !1); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : t && (i = B); const s = this.parseChildren(); n[i] = 1 === Object.keys(s).length ? s[B] : new ee([], s), this.consumeOptional("//") } return n } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new C(4011, !1) } } function zD(e) { return e.segments.length > 0 ? new ee([], { [B]: e }) : e } function GD(e) { const t = {}; for (const r of Object.keys(e.children)) { const i = GD(e.children[r]); if (r === B && 0 === i.segments.length && i.hasChildren()) for (const [s, a] of Object.entries(i.children)) t[s] = a; else (i.segments.length > 0 || i.hasChildren()) && (t[r] = i) } return function y1(e) { if (1 === e.numberOfChildren && e.children[B]) { const t = e.children[B]; return new ee(e.segments.concat(t.segments), t.children) } return e }(new ee(e.segments, t)) } function Zn(e) { return e instanceof Ur } function WD(e) { let t; const o = zD(function n(i) { const s = {}; for (const u of i.children) { const c = n(u); s[u.outlet] = c } const a = new ee(i.url, s); return i === e && (t = a), a }(e.root)); return t ?? o } function qD(e, t, n, r) { let o = e; for (; o.parent;)o = o.parent; if (0 === t.length) return id(o, o, o, n, r); const i = function D1(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new QD(!0, 0, e); let t = 0, n = !1; const r = e.reduce((o, i, s) => { if ("object" == typeof i && null != i) { if (i.outlets) { const a = {}; return Object.entries(i.outlets).forEach(([u, c]) => { a[u] = "string" == typeof c ? c.split("/") : c }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return "string" != typeof i ? [...o, i] : 0 === s ? (i.split("/").forEach((a, u) => { 0 == u && "." === a || (0 == u && "" === a ? n = !0 : ".." === a ? t++ : "" != a && o.push(a)) }), o) : [...o, i] }, []); return new QD(n, t, r) }(t); if (i.toRoot()) return id(o, o, new ee([], {}), n, r); const s = function C1(e, t, n) { if (e.isAbsolute) return new ga(t, !0, 0); if (!n) return new ga(t, !1, NaN); if (null === n.parent) return new ga(n, !0, 0); const r = pa(e.commands[0]) ? 0 : 1; return function w1(e, t, n) { let r = e, o = t, i = n; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new C(4005, !1); o = r.segments.length } return new ga(r, !1, o - i) }(n, n.segments.length - 1 + r, e.numberOfDoubleDots) }(i, o, e), a = s.processChildren ? ci(s.segmentGroup, s.index, i.commands) : YD(s.segmentGroup, s.index, i.commands); return id(o, s.segmentGroup, a, n, r) } function pa(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function ui(e) { return "object" == typeof e && null != e && e.outlets } function id(e, t, n, r, o) { let s, i = {}; r && Object.entries(r).forEach(([u, c]) => { i[u] = Array.isArray(c) ? c.map(l => `${l}`) : `${c}` }), s = e === t ? n : ZD(e, t, n); const a = zD(GD(s)); return new Ur(a, i, o) } function ZD(e, t, n) { const r = {}; return Object.entries(e.children).forEach(([o, i]) => { r[o] = i === t ? n : ZD(i, t, n) }), new ee(e.segments, r) } class QD { constructor(t, n, r) { if (this.isAbsolute = t, this.numberOfDoubleDots = n, this.commands = r, t && r.length > 0 && pa(r[0])) throw new C(4003, !1); const o = r.find(ui); if (o && o !== FD(r)) throw new C(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class ga { constructor(t, n, r) { this.segmentGroup = t, this.processChildren = n, this.index = r } } function YD(e, t, n) { if (e || (e = new ee([], {})), 0 === e.segments.length && e.hasChildren()) return ci(e, t, n); const r = function _1(e, t, n) { let r = 0, o = t; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= n.length) return i; const s = e.segments[o], a = n[r]; if (ui(a)) break; const u = `${a}`, c = r < n.length - 1 ? n[r + 1] : null; if (o > 0 && void 0 === u) break; if (u && c && "object" == typeof c && void 0 === c.outlets) { if (!JD(u, c, s)) return i; r += 2 } else { if (!JD(u, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } }(e, t, n), o = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const i = new ee(e.segments.slice(0, r.pathIndex), {}); return i.children[B] = new ee(e.segments.slice(r.pathIndex), e.children), ci(i, 0, o) } return r.match && 0 === o.length ? new ee(e.segments, {}) : r.match && !e.hasChildren() ? sd(e, t, n) : r.match ? ci(e, 0, o) : sd(e, t, n) } function ci(e, t, n) { if (0 === n.length) return new ee(e.segments, {}); { const r = function E1(e) { return ui(e[0]) ? e[0].outlets : { [B]: e } }(n), o = {}; if (!r[B] && e.children[B] && 1 === e.numberOfChildren && 0 === e.children[B].segments.length) { const i = ci(e.children[B], t, n); return new ee(e.segments, i.children) } return Object.entries(r).forEach(([i, s]) => { "string" == typeof s && (s = [s]), null !== s && (o[i] = YD(e.children[i], t, s)) }), Object.entries(e.children).forEach(([i, s]) => { void 0 === r[i] && (o[i] = s) }), new ee(e.segments, o) } } function sd(e, t, n) { const r = e.segments.slice(0, t); let o = 0; for (; o < n.length;) { const i = n[o]; if (ui(i)) { const u = b1(i.outlets); return new ee(r, u) } if (0 === o && pa(n[0])) { r.push(new ii(e.segments[t].path, KD(n[0]))), o++; continue } const s = ui(i) ? i.outlets[B] : `${i}`, a = o < n.length - 1 ? n[o + 1] : null; s && a && pa(a) ? (r.push(new ii(s, KD(a))), o += 2) : (r.push(new ii(s, {})), o++) } return new ee(r, {}) } function b1(e) { const t = {}; return Object.entries(e).forEach(([n, r]) => { "string" == typeof r && (r = [r]), null !== r && (t[n] = sd(new ee([], {}), 0, r)) }), t } function KD(e) { const t = {}; return Object.entries(e).forEach(([n, r]) => t[n] = `${r}`), t } function JD(e, t, n) { return e == n.path && Ut(t, n.parameters) } const li = "imperative"; class zt { constructor(t, n) { this.id = t, this.url = n } } class ad extends zt { constructor(t, n, r = "imperative", o = null) { super(t, n), this.type = 0, this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Qn extends zt { constructor(t, n, r) { super(t, n), this.urlAfterRedirects = r, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class ma extends zt { constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class di extends zt { constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o, this.type = 16 } } class ud extends zt { constructor(t, n, r, o) { super(t, n), this.error = r, this.target = o, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class I1 extends zt { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class S1 extends zt { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class M1 extends zt { constructor(t, n, r, o, i) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class T1 extends zt { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class A1 extends zt { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class N1 { constructor(t) { this.route = t, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class R1 { constructor(t) { this.route = t, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class x1 { constructor(t) { this.snapshot = t, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class O1 { constructor(t) { this.snapshot = t, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class P1 { constructor(t) { this.snapshot = t, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class F1 { constructor(t) { this.snapshot = t, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class XD { constructor(t, n, r) { this.routerEvent = t, this.position = n, this.anchor = r, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class k1 { constructor() { this.outlet = null, this.route = null, this.injector = null, this.children = new fi, this.attachRef = null } } let fi = (() => { class e { constructor() { this.contexts = new Map } onChildOutletCreated(n, r) { const o = this.getOrCreateContext(n); o.outlet = r, this.contexts.set(n, o) } onChildOutletDestroyed(n) { const r = this.getContext(n); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { const n = this.contexts; return this.contexts = new Map, n } onOutletReAttached(n) { this.contexts = n } getOrCreateContext(n) { let r = this.getContext(n); return r || (r = new k1, this.contexts.set(n, r)), r } getContext(n) { return this.contexts.get(n) || null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); class eC { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const n = this.pathFromRoot(t); return n.length > 1 ? n[n.length - 2] : null } children(t) { const n = cd(t, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(t) { const n = cd(t, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(t) { const n = ld(t, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(o => o.value).filter(o => o !== t) } pathFromRoot(t) { return ld(t, this._root).map(n => n.value) } } function cd(e, t) { if (e === t.value) return t; for (const n of t.children) { const r = cd(e, n); if (r) return r } return null } function ld(e, t) { if (e === t.value) return [t]; for (const n of t.children) { const r = ld(e, n); if (r.length) return r.unshift(t), r } return [] } class un { constructor(t, n) { this.value = t, this.children = n } toString() { return `TreeNode(${this.value})` } } function zr(e) { const t = {}; return e && e.children.forEach(n => t[n.value.outlet] = n), t } class tC extends eC { constructor(t, n) { super(t), this.snapshot = n, dd(this, t) } toString() { return this.snapshot.toString() } } function nC(e, t) { const n = function L1(e, t) { const s = new ya([], {}, {}, "", {}, B, t, null, {}); return new oC("", new un(s, [])) }(0, t), r = new ut([new ii("", {})]), o = new ut({}), i = new ut({}), s = new ut({}), a = new ut(""), u = new In(r, o, s, a, i, B, t, n.root); return u.snapshot = n.root, new tC(new un(u, []), n) } class In { constructor(t, n, r, o, i, s, a, u) { this.urlSubject = t, this.paramsSubject = n, this.queryParamsSubject = r, this.fragmentSubject = o, this.dataSubject = i, this.outlet = s, this.component = a, this._futureSnapshot = u, this.title = this.dataSubject?.pipe(re(c => c[oi])) ?? F(void 0), this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(re(t => Br(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(re(t => Br(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function rC(e, t = "emptyOnly") { const n = e.pathFromRoot; let r = 0; if ("always" !== t) for (r = n.length - 1; r >= 1;) { const o = n[r], i = n[r - 1]; if (o.routeConfig && "" === o.routeConfig.path) r--; else { if (i.component) break; r-- } } return function j1(e) { return e.reduce((t, n) => ({ params: { ...t.params, ...n.params }, data: { ...t.data, ...n.data }, resolve: { ...n.data, ...t.resolve, ...n.routeConfig?.data, ...n._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class ya { get title() { return this.data?.[oi] } constructor(t, n, r, o, i, s, a, u, c) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.routeConfig = u, this._resolve = c } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Br(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Br(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class oC extends eC { constructor(t, n) { super(n), this.url = t, dd(this, n) } toString() { return iC(this._root) } } function dd(e, t) { t.value._routerState = e, t.children.forEach(n => dd(e, n)) } function iC(e) { const t = e.children.length > 0 ? ` { ${e.children.map(iC).join(", ")} } ` : ""; return `${e.value}${t}` } function fd(e) { if (e.snapshot) { const t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, Ut(t.queryParams, n.queryParams) || e.queryParamsSubject.next(n.queryParams), t.fragment !== n.fragment && e.fragmentSubject.next(n.fragment), Ut(t.params, n.params) || e.paramsSubject.next(n.params), function Xx(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!Ut(e[n], t[n])) return !1; return !0 }(t.url, n.url) || e.urlSubject.next(n.url), Ut(t.data, n.data) || e.dataSubject.next(n.data) } else e.snapshot = e._futureSnapshot, e.dataSubject.next(e._futureSnapshot.data) } function hd(e, t) { const n = Ut(e.params, t.params) && function r1(e, t) { return qn(e, t) && e.every((n, r) => Ut(n.parameters, t[r].parameters)) }(e.url, t.url); return n && !(!e.parent != !t.parent) && (!e.parent || hd(e.parent, t.parent)) } let pd = (() => { class e { constructor() { this.activated = null, this._activatedRoute = null, this.name = B, this.activateEvents = new Be, this.deactivateEvents = new Be, this.attachEvents = new Be, this.detachEvents = new Be, this.parentContexts = _(fi), this.location = _(Et), this.changeDetector = _(hl), this.environmentInjector = _(Xt), this.inputBinder = _(va, { optional: !0 }), this.supportsBindingToComponentInputs = !0 } get activatedComponentRef() { return this.activated } ngOnChanges(n) { if (n.name) { const { firstChange: r, previousValue: o } = n.name; if (r) return; this.isTrackedInParentContexts(o) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(o)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(n) { return this.parentContexts.getContext(n)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const n = this.parentContexts.getContext(this.name); n?.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new C(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new C(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new C(4012, !1); this.location.detach(); const n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { const n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new C(4013, !1); this._activatedRoute = n; const o = this.location, s = n.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, u = new V1(n, a, o.injector); this.activated = o.createComponent(s, { index: o.length, injector: u, environmentInjector: r ?? this.environmentInjector }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275dir = je({ type: e, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [xn] }), e })(); class V1 { constructor(t, n, r) { this.route = t, this.childContexts = n, this.parent = r } get(t, n) { return t === In ? this.route : t === fi ? this.childContexts : this.parent.get(t, n) } } const va = new I(""); let sC = (() => { class e { constructor() { this.outletDataSubscriptions = new Map } bindActivatedRouteToOutletComponent(n) { this.unsubscribeFromRouteData(n), this.subscribeToRouteData(n) } unsubscribeFromRouteData(n) { this.outletDataSubscriptions.get(n)?.unsubscribe(), this.outletDataSubscriptions.delete(n) } subscribeToRouteData(n) { const { activatedRoute: r } = n, o = Kl([r.queryParams, r.params, r.data]).pipe(Tt(([i, s, a], u) => (a = { ...i, ...s, ...a }, 0 === u ? F(a) : Promise.resolve(a)))).subscribe(i => { if (!n.isActivated || !n.activatedComponentRef || n.activatedRoute !== r || null === r.component) return void this.unsubscribeFromRouteData(n); const s = function aN(e) { const t = Y(e); if (!t) return null; const n = new Po(t); return { get selector() { return n.selector }, get type() { return n.componentType }, get inputs() { return n.inputs }, get outputs() { return n.outputs }, get ngContentSelectors() { return n.ngContentSelectors }, get isStandalone() { return t.standalone }, get isSignal() { return t.signals } } }(r.component); if (s) for (const { templateName: a } of s.inputs) n.activatedComponentRef.setInput(a, i[a]); else this.unsubscribeFromRouteData(n) }); this.outletDataSubscriptions.set(n, o) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); function hi(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = t.value; const o = function H1(e, t, n) { return t.children.map(r => { for (const o of n.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return hi(e, r, o); return hi(e, r) }) }(e, t, n); return new un(r, o) } { if (e.shouldAttach(t.value)) { const i = e.retrieve(t.value); if (null !== i) { const s = i.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => hi(e, a)), s } } const r = function B1(e) { return new In(new ut(e.url), new ut(e.params), new ut(e.queryParams), new ut(e.fragment), new ut(e.data), e.outlet, e.component, e) }(t.value), o = t.children.map(i => hi(e, i)); return new un(r, o) } } const gd = "ngNavigationCancelingError"; function aC(e, t) { const { redirectTo: n, navigationBehaviorOptions: r } = Zn(t) ? { redirectTo: t, navigationBehaviorOptions: void 0 } : t, o = uC(!1, 0, t); return o.url = n, o.navigationBehaviorOptions = r, o } function uC(e, t, n) { const r = new Error("NavigationCancelingError: " + (e || "")); return r[gd] = !0, r.cancellationCode = t, n && (r.url = n), r } function cC(e) { return lC(e) && Zn(e.url) } function lC(e) { return e && e[gd] } let dC = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Rt({ type: e, selectors: [["ng-component"]], standalone: !0, features: [hy], decls: 1, vars: 0, template: function (n, r) { 1 & n && ne(0, "router-outlet") }, dependencies: [pd], encapsulation: 2 }), e })(); function md(e) { const t = e.children && e.children.map(md), n = t ? { ...e, children: t } : { ...e }; return !n.component && !n.loadComponent && (t || n.loadChildren) && n.outlet && n.outlet !== B && (n.component = dC), n } function St(e) { return e.outlet || B } function pi(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let t = e.parent; t; t = t.parent) { const n = t.routeConfig; if (n?._loadedInjector) return n._loadedInjector; if (n?._injector) return n._injector } return null } class Q1 { constructor(t, n, r, o, i) { this.routeReuseStrategy = t, this.futureState = n, this.currState = r, this.forwardEvent = o, this.inputBindingEnabled = i } activate(t) { const n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, t), fd(this.futureState.root), this.activateChildRoutes(n, r, t) } deactivateChildRoutes(t, n, r) { const o = zr(n); t.children.forEach(i => { const s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), Object.values(o).forEach(i => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (o === i) if (o.component) { const s = r.getContext(o.outlet); s && this.deactivateChildRoutes(t, n, s.children) } else this.deactivateChildRoutes(t, n, r); else i && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(t, n) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n) } detachAndStoreRouteSubtree(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = zr(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = zr(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.route = null) } activateChildRoutes(t, n, r) { const o = zr(n); t.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new F1(i.value.snapshot)) }), t.children.length && this.forwardEvent(new O1(t.value.snapshot)) } activateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (fd(o), o === i) if (o.component) { const s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(t, n, s.children) } else this.activateChildRoutes(t, n, r); else if (o.component) { const s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { const a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), fd(a.route.value), this.activateChildRoutes(t, null, s.children) } else { const a = pi(o.snapshot); s.attachRef = null, s.route = o, s.injector = a, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(t, null, s.children) } } else this.activateChildRoutes(t, null, r) } } class fC { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Da { constructor(t, n) { this.component = t, this.route = n } } function Y1(e, t, n) { const r = e._root; return gi(r, t ? t._root : null, n, [r.value]) } function Gr(e, t) { const n = Symbol(), r = t.get(e, n); return r === n ? "function" != typeof e || function Hw(e) { return null !== Ii(e) }(e) ? t.get(e) : e : r } function gi(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = zr(t); return e.children.forEach(s => { (function J1(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = e.value, s = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { const u = function X1(e, t, n) { if ("function" == typeof n) return n(e, t); switch (n) { case "pathParamsChange": return !qn(e.url, t.url); case "pathParamsOrQueryParamsChange": return !qn(e.url, t.url) || !Ut(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !hd(e, t) || !Ut(e.queryParams, t.queryParams); default: return !hd(e, t) } }(s, i, i.routeConfig.runGuardsAndResolvers); u ? o.canActivateChecks.push(new fC(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), gi(e, t, i.component ? a ? a.children : null : n, r, o), u && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new Da(a.outlet.component, s)) } else s && mi(t, a, o), o.canActivateChecks.push(new fC(r)), gi(e, null, i.component ? a ? a.children : null : n, r, o) })(s, i[s.value.outlet], n, r.concat([s.value]), o), delete i[s.value.outlet] }), Object.entries(i).forEach(([s, a]) => mi(a, n.getContext(s), o)), o } function mi(e, t, n) { const r = zr(e), o = e.value; Object.entries(r).forEach(([i, s]) => { mi(s, o.component ? t ? t.children.getContext(i) : null : t, n) }), n.canDeactivateChecks.push(new Da(o.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, o)) } function yi(e) { return "function" == typeof e } function hC(e) { return e instanceof ua || "EmptyError" === e?.name } const Ca = Symbol("INITIAL_VALUE"); function Wr() { return Tt(e => Kl(e.map(t => t.pipe(Hr(1), function Gx(...e) { const t = Xr(e); return Se((n, r) => { (t ? Jl(e, n, t) : Jl(e, n)).subscribe(r) }) }(Ca)))).pipe(re(t => { for (const n of t) if (!0 !== n) { if (n === Ca) return Ca; if (!1 === n || n instanceof Ur) return n } return !0 }), _n(t => t !== Ca), Hr(1))) } function pC(e) { return function GC(...e) { return Ad(e) }(ze(t => { if (Zn(t)) throw aC(0, t) }), re(t => !0 === t)) } class wa { constructor(t) { this.segmentGroup = t || null } } class gC { constructor(t) { this.urlTree = t } } function qr(e) { return ni(new wa(e)) } function mC(e) { return ni(new gC(e)) } class DO { constructor(t, n) { this.urlSerializer = t, this.urlTree = n } noMatchError(t) { return new C(4002, !1) } lineralizeSegments(t, n) { let r = [], o = n.root; for (; ;) { if (r = r.concat(o.segments), 0 === o.numberOfChildren) return F(r); if (o.numberOfChildren > 1 || !o.children[B]) return ni(new C(4e3, !1)); o = o.children[B] } } applyRedirectCommands(t, n, r) { return this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), t, r) } applyRedirectCreateUrlTree(t, n, r, o) { const i = this.createSegmentGroup(t, n.root, r, o); return new Ur(i, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(t, n) { const r = {}; return Object.entries(t).forEach(([o, i]) => { if ("string" == typeof i && i.startsWith(":")) { const a = i.substring(1); r[o] = n[a] } else r[o] = i }), r } createSegmentGroup(t, n, r, o) { const i = this.createSegments(t, n.segments, r, o); let s = {}; return Object.entries(n.children).forEach(([a, u]) => { s[a] = this.createSegmentGroup(t, u, r, o) }), new ee(i, s) } createSegments(t, n, r, o) { return n.map(i => i.path.startsWith(":") ? this.findPosParam(t, i, o) : this.findOrReturn(i, r)) } findPosParam(t, n, r) { const o = r[n.path.substring(1)]; if (!o) throw new C(4001, !1); return o } findOrReturn(t, n) { let r = 0; for (const o of n) { if (o.path === t.path) return n.splice(r), o; r++ } return t } } const yd = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function CO(e, t, n, r, o) { const i = vd(e, t, n); return i.matched ? (r = function U1(e, t) { return e.providers && !e._injector && (e._injector = Hc(e.providers, t, `Route: ${e.path}`)), e._injector ?? t }(t, r), function mO(e, t, n, r) { const o = t.canMatch; return o && 0 !== o.length ? F(o.map(s => { const a = Gr(s, e); return bn(function iO(e) { return e && yi(e.canMatch) }(a) ? a.canMatch(t, n) : e.runInContext(() => a(t, n))) })).pipe(Wr(), pC()) : F(!0) }(r, t, n).pipe(re(s => !0 === s ? i : { ...yd }))) : F(i) } function vd(e, t, n) { if ("" === t.path) return "full" === t.pathMatch && (e.hasChildren() || n.length > 0) ? { ...yd } : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; const o = (t.matcher || Jx)(n, e, t); if (!o) return { ...yd }; const i = {}; Object.entries(o.posParams ?? {}).forEach(([a, u]) => { i[a] = u.path }); const s = o.consumed.length > 0 ? { ...i, ...o.consumed[o.consumed.length - 1].parameters } : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: n.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function yC(e, t, n, r) { return n.length > 0 && function _O(e, t, n) { return n.some(r => Ea(e, t, r) && St(r) !== B) }(e, n, r) ? { segmentGroup: new ee(t, EO(r, new ee(n, e.children))), slicedSegments: [] } : 0 === n.length && function bO(e, t, n) { return n.some(r => Ea(e, t, r)) }(e, n, r) ? { segmentGroup: new ee(e.segments, wO(e, 0, n, r, e.children)), slicedSegments: n } : { segmentGroup: new ee(e.segments, e.children), slicedSegments: n } } function wO(e, t, n, r, o) { const i = {}; for (const s of r) if (Ea(e, n, s) && !o[St(s)]) { const a = new ee([], {}); i[St(s)] = a } return { ...o, ...i } } function EO(e, t) { const n = {}; n[B] = t; for (const r of e) if ("" === r.path && St(r) !== B) { const o = new ee([], {}); n[St(r)] = o } return n } function Ea(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path } class TO { constructor(t, n, r, o, i, s, a) { this.injector = t, this.configLoader = n, this.rootComponentType = r, this.config = o, this.urlTree = i, this.paramsInheritanceStrategy = s, this.urlSerializer = a, this.allowRedirects = !0, this.applyRedirects = new DO(this.urlSerializer, this.urlTree) } noMatchError(t) { return new C(4002, !1) } recognize() { const t = yC(this.urlTree.root, [], [], this.config).segmentGroup; return this.processSegmentGroup(this.injector, this.config, t, B).pipe(Wn(n => { if (n instanceof gC) return this.allowRedirects = !1, this.urlTree = n.urlTree, this.match(n.urlTree); throw n instanceof wa ? this.noMatchError(n) : n }), re(n => { const r = new ya([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, B, this.rootComponentType, null, {}), o = new un(r, n), i = new oC("", o), s = function v1(e, t, n = null, r = null) { return qD(WD(e), t, n, r) }(r, [], this.urlTree.queryParams, this.urlTree.fragment); return s.queryParams = this.urlTree.queryParams, i.url = this.urlSerializer.serialize(s), this.inheritParamsAndData(i._root), { state: i, tree: s } })) } match(t) { return this.processSegmentGroup(this.injector, this.config, t.root, B).pipe(Wn(r => { throw r instanceof wa ? this.noMatchError(r) : r })) } inheritParamsAndData(t) { const n = t.value, r = rC(n, this.paramsInheritanceStrategy); n.params = Object.freeze(r.params), n.data = Object.freeze(r.data), t.children.forEach(o => this.inheritParamsAndData(o)) } processSegmentGroup(t, n, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.processChildren(t, n, r) : this.processSegment(t, n, r, r.segments, o, !0) } processChildren(t, n, r) { const o = []; for (const i of Object.keys(r.children)) "primary" === i ? o.unshift(i) : o.push(i); return Ne(o).pipe(ri(i => { const s = r.children[i], a = function q1(e, t) { const n = e.filter(r => St(r) === t); return n.push(...e.filter(r => St(r) !== t)), n }(n, i); return this.processSegmentGroup(t, a, s, i) }), function Zx(e, t) { return Se(function qx(e, t, n, r, o) { return (i, s) => { let a = n, u = t, c = 0; i.subscribe(Me(s, l => { const d = c++; u = a ? e(u, l, d) : (a = !0, l), r && s.next(u) }, o && (() => { a && s.next(u), s.complete() }))) } }(e, t, arguments.length >= 2, !0)) }((i, s) => (i.push(...s), i)), ca(null), function Qx(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? _n((o, i) => e(o, i, r)) : ln, ed(1), n ? ca(t) : OD(() => new ua)) }(), Ae(i => { if (null === i) return qr(r); const s = vC(i); return function AO(e) { e.sort((t, n) => t.value.outlet === B ? -1 : n.value.outlet === B ? 1 : t.value.outlet.localeCompare(n.value.outlet)) }(s), F(s) })) } processSegment(t, n, r, o, i, s) { return Ne(n).pipe(ri(a => this.processSegmentAgainstRoute(a._injector ?? t, n, a, r, o, i, s).pipe(Wn(u => { if (u instanceof wa) return F(null); throw u }))), Gn(a => !!a), Wn(a => { if (hC(a)) return function SO(e, t, n) { return 0 === t.length && !e.children[n] }(r, o, i) ? F([]) : qr(r); throw a })) } processSegmentAgainstRoute(t, n, r, o, i, s, a) { return function IO(e, t, n, r) { return !!(St(e) === r || r !== B && Ea(t, n, e)) && ("**" === e.path || vd(t, e, n).matched) }(r, o, i, s) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, o, r, i, s, a) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, o, n, r, i, s) : qr(o) : qr(o) } expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { return "**" === o.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, r, o, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, o) { const i = this.applyRedirects.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? mC(i) : this.applyRedirects.lineralizeSegments(r, i).pipe(Ae(s => { const a = new ee(s, {}); return this.processSegment(t, n, a, s, o, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { const { matched: a, consumedSegments: u, remainingSegments: c, positionalParamSegments: l } = vd(n, o, i); if (!a) return qr(n); const d = this.applyRedirects.applyRedirectCommands(u, o.redirectTo, l); return o.redirectTo.startsWith("/") ? mC(d) : this.applyRedirects.lineralizeSegments(o, d).pipe(Ae(f => this.processSegment(t, r, n, f.concat(c), s, !1))) } matchSegmentAgainstRoute(t, n, r, o, i, s) { let a; if ("**" === r.path) { const u = o.length > 0 ? FD(o).parameters : {}; a = F({ snapshot: new ya(o, u, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, DC(r), St(r), r.component ?? r._loadedComponent ?? null, r, CC(r)), consumedSegments: [], remainingSegments: [] }), n.children = {} } else a = CO(n, r, o, t).pipe(re(({ matched: u, consumedSegments: c, remainingSegments: l, parameters: d }) => u ? { snapshot: new ya(c, d, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, DC(r), St(r), r.component ?? r._loadedComponent ?? null, r, CC(r)), consumedSegments: c, remainingSegments: l } : null)); return a.pipe(Tt(u => null === u ? qr(n) : this.getChildConfig(t = r._injector ?? t, r, o).pipe(Tt(({ routes: c }) => { const l = r._loadedInjector ?? t, { snapshot: d, consumedSegments: f, remainingSegments: h } = u, { segmentGroup: p, slicedSegments: g } = yC(n, f, h, c); if (0 === g.length && p.hasChildren()) return this.processChildren(l, c, p).pipe(re(D => null === D ? null : [new un(d, D)])); if (0 === c.length && 0 === g.length) return F([new un(d, [])]); const v = St(r) === i; return this.processSegment(l, c, p, g, v ? B : i, !0).pipe(re(D => [new un(d, D)])) })))) } getChildConfig(t, n, r) { return n.children ? F({ routes: n.children, injector: t }) : n.loadChildren ? void 0 !== n._loadedRoutes ? F({ routes: n._loadedRoutes, injector: n._loadedInjector }) : function gO(e, t, n, r) { const o = t.canLoad; return void 0 === o || 0 === o.length ? F(!0) : F(o.map(s => { const a = Gr(s, e); return bn(function tO(e) { return e && yi(e.canLoad) }(a) ? a.canLoad(t, n) : e.runInContext(() => a(t, n))) })).pipe(Wr(), pC()) }(t, n, r).pipe(Ae(o => o ? this.configLoader.loadChildren(t, n).pipe(ze(i => { n._loadedRoutes = i.routes, n._loadedInjector = i.injector })) : function vO(e) { return ni(uC(!1, 3)) }())) : F({ routes: [], injector: t }) } } function NO(e) { const t = e.value.routeConfig; return t && "" === t.path } function vC(e) { const t = [], n = new Set; for (const r of e) { if (!NO(r)) { t.push(r); continue } const o = t.find(i => r.value.routeConfig === i.value.routeConfig); void 0 !== o ? (o.children.push(...r.children), n.add(o)) : t.push(r) } for (const r of n) { const o = vC(r.children); t.push(new un(r.value, o)) } return t.filter(r => !n.has(r)) } function DC(e) { return e.data || {} } function CC(e) { return e.resolve || {} } function wC(e) { return "string" == typeof e.title || null === e.title } function Dd(e) { return Tt(t => { const n = e(t); return n ? Ne(n).pipe(re(() => t)) : F(t) }) } const Zr = new I("ROUTES"); let Cd = (() => { class e { constructor() { this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = _(iv) } loadComponent(n) { if (this.componentLoaders.get(n)) return this.componentLoaders.get(n); if (n._loadedComponent) return F(n._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(n); const r = bn(n.loadComponent()).pipe(re(EC), ze(i => { this.onLoadEndListener && this.onLoadEndListener(n), n._loadedComponent = i }), td(() => { this.componentLoaders.delete(n) })), o = new xD(r, () => new Gt).pipe(Xl()); return this.componentLoaders.set(n, o), o } loadChildren(n, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return F({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); const i = this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(re(a => { this.onLoadEndListener && this.onLoadEndListener(r); let u, c; return Array.isArray(a) ? c = a : (u = a.create(n).injector, c = u.get(Zr, [], A.Self | A.Optional).flat()), { routes: c.map(md), injector: u } }), td(() => { this.childrenLoaders.delete(r) })), s = new xD(i, () => new Gt).pipe(Xl()); return this.childrenLoaders.set(r, s), s } loadModuleFactoryOrRoutes(n) { return bn(n()).pipe(re(EC), Ae(r => r instanceof dy || Array.isArray(r) ? F(r) : Ne(this.compiler.compileModuleAsync(r)))) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function EC(e) { return function LO(e) { return e && "object" == typeof e && "default" in e }(e) ? e.default : e } let _a = (() => { class e { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.lastSuccessfulNavigation = null, this.events = new Gt, this.configLoader = _(Cd), this.environmentInjector = _(Xt), this.urlSerializer = _(si), this.rootContexts = _(fi), this.inputBindingEnabled = null !== _(va, { optional: !0 }), this.navigationId = 0, this.afterPreactivation = () => F(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = o => this.events.next(new R1(o)), this.configLoader.onLoadStartListener = o => this.events.next(new N1(o)) } complete() { this.transitions?.complete() } handleNavigationRequest(n) { const r = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...n, id: r }) } setupNavigations(n) { return this.transitions = new ut({ id: 0, currentUrlTree: n.currentUrlTree, currentRawUrl: n.currentUrlTree, extractedUrl: n.urlHandlingStrategy.extract(n.currentUrlTree), urlAfterRedirects: n.urlHandlingStrategy.extract(n.currentUrlTree), rawUrl: n.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: li, restoredState: null, currentSnapshot: n.routerState.snapshot, targetSnapshot: null, currentRouterState: n.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe(_n(r => 0 !== r.id), re(r => ({ ...r, extractedUrl: n.urlHandlingStrategy.extract(r.rawUrl) })), Tt(r => { let o = !1, i = !1; return F(r).pipe(ze(s => { this.currentNavigation = { id: s.id, initialUrl: s.rawUrl, extractedUrl: s.extractedUrl, trigger: s.source, extras: s.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), Tt(s => { const a = n.browserUrlTree.toString(), u = !n.navigated || s.extractedUrl.toString() !== a || a !== n.currentUrlTree.toString(); if (!u && "reload" !== (s.extras.onSameUrlNavigation ?? n.onSameUrlNavigation)) { const l = ""; return this.events.next(new di(s.id, n.serializeUrl(r.rawUrl), l, 0)), n.rawUrlTree = s.rawUrl, s.resolve(null), Mt } if (n.urlHandlingStrategy.shouldProcessUrl(s.rawUrl)) return _C(s.source) && (n.browserUrlTree = s.extractedUrl), F(s).pipe(Tt(l => { const d = this.transitions?.getValue(); return this.events.next(new ad(l.id, this.urlSerializer.serialize(l.extractedUrl), l.source, l.restoredState)), d !== this.transitions?.getValue() ? Mt : Promise.resolve(l) }), function RO(e, t, n, r, o, i) { return Ae(s => function MO(e, t, n, r, o, i, s = "emptyOnly") { return new TO(e, t, n, r, o, s, i).recognize() }(e, t, n, r, s.extractedUrl, o, i).pipe(re(({ state: a, tree: u }) => ({ ...s, targetSnapshot: a, urlAfterRedirects: u })))) }(this.environmentInjector, this.configLoader, this.rootComponentType, n.config, this.urlSerializer, n.paramsInheritanceStrategy), ze(l => { if (r.targetSnapshot = l.targetSnapshot, r.urlAfterRedirects = l.urlAfterRedirects, this.currentNavigation = { ...this.currentNavigation, finalUrl: l.urlAfterRedirects }, "eager" === n.urlUpdateStrategy) { if (!l.extras.skipLocationChange) { const f = n.urlHandlingStrategy.merge(l.urlAfterRedirects, l.rawUrl); n.setBrowserUrl(f, l) } n.browserUrlTree = l.urlAfterRedirects } const d = new I1(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot); this.events.next(d) })); if (u && n.urlHandlingStrategy.shouldProcessUrl(n.rawUrlTree)) { const { id: l, extractedUrl: d, source: f, restoredState: h, extras: p } = s, g = new ad(l, this.urlSerializer.serialize(d), f, h); this.events.next(g); const v = nC(0, this.rootComponentType).snapshot; return F(r = { ...s, targetSnapshot: v, urlAfterRedirects: d, extras: { ...p, skipLocationChange: !1, replaceUrl: !1 } }) } { const l = ""; return this.events.next(new di(s.id, n.serializeUrl(r.extractedUrl), l, 1)), n.rawUrlTree = s.rawUrl, s.resolve(null), Mt } }), ze(s => { const a = new S1(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot); this.events.next(a) }), re(s => r = { ...s, guards: Y1(s.targetSnapshot, s.currentSnapshot, this.rootContexts) }), function aO(e, t) { return Ae(n => { const { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = n; return 0 === s.length && 0 === i.length ? F({ ...n, guardsResult: !0 }) : function uO(e, t, n, r) { return Ne(e).pipe(Ae(o => function pO(e, t, n, r, o) { const i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return i && 0 !== i.length ? F(i.map(a => { const u = pi(t) ?? o, c = Gr(a, u); return bn(function oO(e) { return e && yi(e.canDeactivate) }(c) ? c.canDeactivate(e, t, n, r) : u.runInContext(() => c(e, t, n, r))).pipe(Gn()) })).pipe(Wr()) : F(!0) }(o.component, o.route, n, t, r)), Gn(o => !0 !== o, !0)) }(s, r, o, e).pipe(Ae(a => a && function eO(e) { return "boolean" == typeof e }(a) ? function cO(e, t, n, r) { return Ne(t).pipe(ri(o => Jl(function dO(e, t) { return null !== e && t && t(new x1(e)), F(!0) }(o.route.parent, r), function lO(e, t) { return null !== e && t && t(new P1(e)), F(!0) }(o.route, r), function hO(e, t, n) { const r = t[t.length - 1], i = t.slice(0, t.length - 1).reverse().map(s => function K1(e) { const t = e.routeConfig ? e.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: e, guards: t } : null }(s)).filter(s => null !== s).map(s => RD(() => F(s.guards.map(u => { const c = pi(s.node) ?? n, l = Gr(u, c); return bn(function rO(e) { return e && yi(e.canActivateChild) }(l) ? l.canActivateChild(r, e) : c.runInContext(() => l(r, e))).pipe(Gn()) })).pipe(Wr()))); return F(i).pipe(Wr()) }(e, o.path, n), function fO(e, t, n) { const r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || 0 === r.length) return F(!0); const o = r.map(i => RD(() => { const s = pi(t) ?? n, a = Gr(i, s); return bn(function nO(e) { return e && yi(e.canActivate) }(a) ? a.canActivate(t, e) : s.runInContext(() => a(t, e))).pipe(Gn()) })); return F(o).pipe(Wr()) }(e, o.route, n))), Gn(o => !0 !== o, !0)) }(r, i, e, t) : F(a)), re(a => ({ ...n, guardsResult: a }))) }) }(this.environmentInjector, s => this.events.next(s)), ze(s => { if (r.guardsResult = s.guardsResult, Zn(s.guardsResult)) throw aC(0, s.guardsResult); const a = new M1(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(s.urlAfterRedirects), s.targetSnapshot, !!s.guardsResult); this.events.next(a) }), _n(s => !!s.guardsResult || (n.restoreHistory(s), this.cancelNavigationTransition(s, "", 3), !1)), Dd(s => { if (s.guards.canActivateChecks.length) return F(s).pipe(ze(a => { const u = new T1(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(u) }), Tt(a => { let u = !1; return F(a).pipe(function xO(e, t) { return Ae(n => { const { targetSnapshot: r, guards: { canActivateChecks: o } } = n; if (!o.length) return F(n); let i = 0; return Ne(o).pipe(ri(s => function OO(e, t, n, r) { const o = e.routeConfig, i = e._resolve; return void 0 !== o?.title && !wC(o) && (i[oi] = o.title), function PO(e, t, n, r) { const o = function FO(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] }(e); if (0 === o.length) return F({}); const i = {}; return Ne(o).pipe(Ae(s => function kO(e, t, n, r) { const o = pi(t) ?? r, i = Gr(e, o); return bn(i.resolve ? i.resolve(t, n) : o.runInContext(() => i(t, n))) }(e[s], t, n, r).pipe(Gn(), ze(a => { i[s] = a }))), ed(1), function Yx(e) { return re(() => e) }(i), Wn(s => hC(s) ? Mt : ni(s))) }(i, e, t, r).pipe(re(s => (e._resolvedData = s, e.data = rC(e, n).resolve, o && wC(o) && (e.data[oi] = o.title), null))) }(s.route, r, e, t)), ze(() => i++), ed(1), Ae(s => i === o.length ? F(n) : Mt)) }) }(n.paramsInheritanceStrategy, this.environmentInjector), ze({ next: () => u = !0, complete: () => { u || (n.restoreHistory(a), this.cancelNavigationTransition(a, "", 2)) } })) }), ze(a => { const u = new A1(a.id, this.urlSerializer.serialize(a.extractedUrl), this.urlSerializer.serialize(a.urlAfterRedirects), a.targetSnapshot); this.events.next(u) })) }), Dd(s => { const a = u => { const c = []; u.routeConfig?.loadComponent && !u.routeConfig._loadedComponent && c.push(this.configLoader.loadComponent(u.routeConfig).pipe(ze(l => { u.component = l }), re(() => { }))); for (const l of u.children) c.push(...a(l)); return c }; return Kl(a(s.targetSnapshot.root)).pipe(ca(), Hr(1)) }), Dd(() => this.afterPreactivation()), re(s => { const a = function $1(e, t, n) { const r = hi(e, t._root, n ? n._root : void 0); return new tC(r, t) }(n.routeReuseStrategy, s.targetSnapshot, s.currentRouterState); return r = { ...s, targetRouterState: a } }), ze(s => { n.currentUrlTree = s.urlAfterRedirects, n.rawUrlTree = n.urlHandlingStrategy.merge(s.urlAfterRedirects, s.rawUrl), n.routerState = s.targetRouterState, "deferred" === n.urlUpdateStrategy && (s.extras.skipLocationChange || n.setBrowserUrl(n.rawUrlTree, s), n.browserUrlTree = s.urlAfterRedirects) }), ((e, t, n, r) => re(o => (new Q1(t, o.targetRouterState, o.currentRouterState, n, r).activate(e), o)))(this.rootContexts, n.routeReuseStrategy, s => this.events.next(s), this.inputBindingEnabled), Hr(1), ze({ next: s => { o = !0, this.lastSuccessfulNavigation = this.currentNavigation, n.navigated = !0, this.events.next(new Qn(s.id, this.urlSerializer.serialize(s.extractedUrl), this.urlSerializer.serialize(n.currentUrlTree))), n.titleStrategy?.updateTitle(s.targetRouterState.snapshot), s.resolve(!0) }, complete: () => { o = !0 } }), td(() => { o || i || this.cancelNavigationTransition(r, "", 1), this.currentNavigation?.id === r.id && (this.currentNavigation = null) }), Wn(s => { if (i = !0, lC(s)) { cC(s) || (n.navigated = !0, n.restoreHistory(r, !0)); const a = new ma(r.id, this.urlSerializer.serialize(r.extractedUrl), s.message, s.cancellationCode); if (this.events.next(a), cC(s)) { const u = n.urlHandlingStrategy.merge(s.url, n.rawUrlTree), c = { skipLocationChange: r.extras.skipLocationChange, replaceUrl: "eager" === n.urlUpdateStrategy || _C(r.source) }; n.scheduleNavigation(u, li, null, c, { resolve: r.resolve, reject: r.reject, promise: r.promise }) } else r.resolve(!1) } else { n.restoreHistory(r, !0); const a = new ud(r.id, this.urlSerializer.serialize(r.extractedUrl), s, r.targetSnapshot ?? void 0); this.events.next(a); try { r.resolve(n.errorHandler(s)) } catch (u) { r.reject(u) } } return Mt })) })) } cancelNavigationTransition(n, r, o) { const i = new ma(n.id, this.urlSerializer.serialize(n.extractedUrl), r, o); this.events.next(i), n.resolve(!1) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function _C(e) { return e !== li } let bC = (() => { class e { buildTitle(n) { let r, o = n.root; for (; void 0 !== o;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === B); return r } getResolvedTitleForRoute(n) { return n.data[oi] } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return _(jO) }, providedIn: "root" }), e })(), jO = (() => { class e extends bC { constructor(n) { super(), this.title = n } updateTitle(n) { const r = this.buildTitle(n); void 0 !== r && this.title.setTitle(r) } } return e.\u0275fac = function (n) { return new (n || e)(R(SD)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), VO = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return _(HO) }, providedIn: "root" }), e })(); class $O { shouldDetach(t) { return !1 } store(t, n) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, n) { return t.routeConfig === n.routeConfig } } let HO = (() => { class e extends $O { } return e.\u0275fac = function () { let t; return function (r) { return (t || (t = function gh(e) { return qt(() => { const t = e.prototype.constructor, n = t[Zt] || gu(t), r = Object.prototype; let o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { const i = o[Zt] || gu(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) }(e)))(r || e) } }(), e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const ba = new I("", { providedIn: "root", factory: () => ({}) }); let BO = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: function () { return _(UO) }, providedIn: "root" }), e })(), UO = (() => { class e { shouldProcessUrl(n) { return !0 } extract(n) { return n } merge(n, r) { return n } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); var st = (() => ((st = st || {})[st.COMPLETE = 0] = "COMPLETE", st[st.FAILED = 1] = "FAILED", st[st.REDIRECTING = 2] = "REDIRECTING", st))(); function IC(e, t) { e.events.pipe(_n(n => n instanceof Qn || n instanceof ma || n instanceof ud || n instanceof di), re(n => n instanceof Qn || n instanceof di ? st.COMPLETE : n instanceof ma && (0 === n.code || 1 === n.code) ? st.REDIRECTING : st.FAILED), _n(n => n !== st.REDIRECTING), Hr(1)).subscribe(() => { t() }) } function zO(e) { throw e } function GO(e, t, n) { return t.parse("/") } const WO = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, qO = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let gt = (() => { class e { get navigationId() { return this.navigationTransitions.navigationId } get browserPageId() { if ("computed" === this.canceledNavigationResolution) return this.location.getState()?.\u0275routerPageId } get events() { return this.navigationTransitions.events } constructor() { this.disposed = !1, this.currentPageId = 0, this.console = _(rv), this.isNgZoneEnabled = !1, this.options = _(ba, { optional: !0 }) || {}, this.pendingTasks = _(ov), this.errorHandler = this.options.errorHandler || zO, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || GO, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = _(BO), this.routeReuseStrategy = _(VO), this.titleStrategy = _(bC), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = _(Zr, { optional: !0 })?.flat() ?? [], this.navigationTransitions = _(_a), this.urlSerializer = _(si), this.location = _(bl), this.componentInputBindingEnabled = !!_(va, { optional: !0 }), this.isNgZoneEnabled = _(ce) instanceof ce && ce.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new Ur, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = nC(0, null), this.navigationTransitions.setupNavigations(this).subscribe(n => { this.lastSuccessfulId = n.id, this.currentPageId = this.browserPageId ?? 0 }, n => { this.console.warn(`Unhandled Navigation Error: ${n}`) }) } resetRootComponentType(n) { this.routerState.root.component = n, this.navigationTransitions.rootComponentType = n } initialNavigation() { if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) { const n = this.location.getState(); this.navigateToSyncWithBrowser(this.location.path(!0), li, n) } } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(n => { const r = "popstate" === n.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { this.navigateToSyncWithBrowser(n.url, r, n.state) }, 0) })) } navigateToSyncWithBrowser(n, r, o) { const i = { replaceUrl: !0 }, s = o?.navigationId ? o : null; if (o) { const u = { ...o }; delete u.navigationId, delete u.\u0275routerPageId, 0 !== Object.keys(u).length && (i.state = u) } const a = this.parseUrl(n); this.scheduleNavigation(a, r, s, i) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(n) { this.config = n.map(md), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(n, r = {}) { const { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: u } = r, c = u ? this.currentUrlTree.fragment : s; let d, l = null; switch (a) { case "merge": l = { ...this.currentUrlTree.queryParams, ...i }; break; case "preserve": l = this.currentUrlTree.queryParams; break; default: l = i || null }null !== l && (l = this.removeEmptyProps(l)); try { d = WD(o ? o.snapshot : this.routerState.snapshot.root) } catch { ("string" != typeof n[0] || !n[0].startsWith("/")) && (n = []), d = this.currentUrlTree.root } return qD(d, n, l, c ?? null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { const o = Zn(n) ? n : this.parseUrl(n), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, li, null, r) } navigate(n, r = { skipLocationChange: !1 }) { return function ZO(e) { for (let t = 0; t < e.length; t++)if (null == e[t]) throw new C(4008, !1) }(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { let r; try { r = this.urlSerializer.parse(n) } catch (o) { r = this.malformedUriErrorHandler(o, this.urlSerializer, n) } return r } isActive(n, r) { let o; if (o = !0 === r ? { ...WO } : !1 === r ? { ...qO } : r, Zn(n)) return LD(this.currentUrlTree, n, o); const i = this.parseUrl(n); return LD(this.currentUrlTree, i, o) } removeEmptyProps(n) { return Object.keys(n).reduce((r, o) => { const i = n[o]; return null != i && (r[o] = i), r }, {}) } scheduleNavigation(n, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, u, c; s ? (a = s.resolve, u = s.reject, c = s.promise) : c = new Promise((d, f) => { a = d, u = f }); const l = this.pendingTasks.add(); return IC(this, () => { queueMicrotask(() => this.pendingTasks.remove(l)) }), this.navigationTransitions.handleNavigationRequest({ source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: n, extras: i, resolve: a, reject: u, promise: c, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), c.catch(d => Promise.reject(d)) } setBrowserUrl(n, r) { const o = this.urlSerializer.serialize(n); if (this.location.isCurrentPathEqualTo(o) || r.extras.replaceUrl) { const s = { ...r.extras.state, ...this.generateNgRouterState(r.id, this.browserPageId) }; this.location.replaceState(o, "", s) } else { const i = { ...r.extras.state, ...this.generateNgRouterState(r.id, (this.browserPageId ?? 0) + 1) }; this.location.go(o, "", i) } } restoreHistory(n, r = !1) { if ("computed" === this.canceledNavigationResolution) { const i = this.currentPageId - (this.browserPageId ?? this.currentPageId); 0 !== i ? this.location.historyGo(i) : this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === i && (this.resetState(n), this.browserUrlTree = n.currentUrlTree, this.resetUrlToCurrentUrlTree()) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(n), this.resetUrlToCurrentUrlTree()) } resetState(n) { this.routerState = n.currentRouterState, this.currentUrlTree = n.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(n, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), Qr = (() => { class e { constructor(n, r, o, i, s, a) { this.router = n, this.route = r, this.tabIndexAttribute = o, this.renderer = i, this.el = s, this.locationStrategy = a, this.href = null, this.commands = null, this.onChanges = new Gt, this.preserveFragment = !1, this.skipLocationChange = !1, this.replaceUrl = !1; const u = s.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = "a" === u || "area" === u, this.isAnchorElement ? this.subscription = n.events.subscribe(c => { c instanceof Qn && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } setTabIndexIfNotOnNativeEl(n) { null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", n) } ngOnChanges(n) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } set routerLink(n) { null != n ? (this.commands = Array.isArray(n) ? n : [n], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null)) } onClick(n, r, o, i, s) { return !!(null === this.urlTree || this.isAnchorElement && (0 !== n || r || o || i || s || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state }), !this.isAnchorElement) } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null; const n = null === this.href ? null : function pp(e, t, n) { return function Ub(e, t) { return "src" === t && ("embed" === e || "frame" === e || "iframe" === e || "media" === e || "script" === e) || "href" === t && ("base" === e || "link" === e) ? hp : bo }(t, n)(e) }(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", n) } applyAttributeValue(n, r) { const o = this.renderer, i = this.el.nativeElement; null !== r ? o.setAttribute(i, n, r) : o.removeAttribute(i, n) } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } } return e.\u0275fac = function (n) { return new (n || e)(S(gt), S(In), function Zi(e) { return function f_(e, t) { if ("class" === t) return e.classes; if ("style" === t) return e.styles; const n = e.attrs; if (n) { const r = n.length; let o = 0; for (; o < r;) { const i = n[o]; if (lf(i)) break; if (0 === i) o += 2; else if ("number" == typeof i) for (o++; o < r && "string" == typeof n[o];)o++; else { if (i === t) return n[o + 1]; o += 2 } } } return null }(Re(), e) }("tabindex"), S(Cs), S(Dn), S(zn)) }, e.\u0275dir = je({ type: e, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (n, r) { 1 & n && Vo("click", function (i) { return r.onClick(i.button, i.ctrlKey, i.shiftKey, i.altKey, i.metaKey) }), 2 & n && Cc("target", r.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: ["preserveFragment", "preserveFragment", Cl], skipLocationChange: ["skipLocationChange", "skipLocationChange", Cl], replaceUrl: ["replaceUrl", "replaceUrl", Cl], routerLink: "routerLink" }, standalone: !0, features: [bg, xn] }), e })(); class SC { } let KO = (() => { class e { constructor(n, r, o, i, s) { this.router = n, this.injector = o, this.preloadingStrategy = i, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(_n(n => n instanceof Qn), ri(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(n, r) { const o = []; for (const i of r) { i.providers && !i._injector && (i._injector = Hc(i.providers, n, `Route: ${i.path}`)); const s = i._injector ?? n, a = i._loadedInjector ?? s; (i.loadChildren && !i._loadedRoutes && void 0 === i.canLoad || i.loadComponent && !i._loadedComponent) && o.push(this.preloadConfig(s, i)), (i.children || i._loadedRoutes) && o.push(this.processRoutes(a, i.children ?? i._loadedRoutes)) } return Ne(o).pipe(Yn()) } preloadConfig(n, r) { return this.preloadingStrategy.preload(r, () => { let o; o = r.loadChildren && void 0 === r.canLoad ? this.loader.loadChildren(n, r) : F(null); const i = o.pipe(Ae(s => null === s ? F(void 0) : (r._loadedRoutes = s.routes, r._loadedInjector = s.injector, this.processRoutes(s.injector ?? n, s.routes)))); return r.loadComponent && !r._loadedComponent ? Ne([i, this.loader.loadComponent(r)]).pipe(Yn()) : i }) } } return e.\u0275fac = function (n) { return new (n || e)(R(gt), R(iv), R(Xt), R(SC), R(Cd)) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const wd = new I(""); let MC = (() => { class e { constructor(n, r, o, i, s = {}) { this.urlSerializer = n, this.transitions = r, this.viewportScroller = o, this.zone = i, this.options = s, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, s.scrollPositionRestoration = s.scrollPositionRestoration || "disabled", s.anchorScrolling = s.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(n => { n instanceof ad ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = n.navigationTrigger, this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof Qn ? (this.lastId = n.id, this.scheduleScrollEvent(n, this.urlSerializer.parse(n.urlAfterRedirects).fragment)) : n instanceof di && 0 === n.code && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(n, this.urlSerializer.parse(n.url).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(n => { n instanceof XD && (n.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(n.position) : n.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(n.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(n, r) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new XD(n, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } } return e.\u0275fac = function (n) { !function Kp() { throw new Error("invalid") }() }, e.\u0275prov = x({ token: e, factory: e.\u0275fac }), e })(); function cn(e, t) { return { \u0275kind: e, \u0275providers: t } } function AC() { const e = _(tn); return t => { const n = e.get(Vr); if (t !== n.components[0]) return; const r = e.get(gt), o = e.get(NC); 1 === e.get(Ed) && r.initialNavigation(), e.get(RC, null, A.Optional)?.setUpPreloading(), e.get(wd, null, A.Optional)?.init(), r.resetRootComponentType(n.componentTypes[0]), o.closed || (o.next(), o.complete(), o.unsubscribe()) } } const NC = new I("", { factory: () => new Gt }), Ed = new I("", { providedIn: "root", factory: () => 1 }), RC = new I(""); function tP(e) { return cn(0, [{ provide: RC, useExisting: KO }, { provide: SC, useExisting: e }]) } const xC = new I("ROUTER_FORROOT_GUARD"), rP = [bl, { provide: si, useClass: nd }, gt, fi, { provide: In, useFactory: function TC(e) { return e.routerState.root }, deps: [gt] }, Cd, []]; function oP() { return new mv("Router", gt) } let OC = (() => { class e { constructor(n) { } static forRoot(n, r) { return { ngModule: e, providers: [rP, [], { provide: Zr, multi: !0, useValue: n }, { provide: xC, useFactory: uP, deps: [[gt, new Ki, new Ji]] }, { provide: ba, useValue: r || {} }, r?.useHash ? { provide: zn, useClass: fN } : { provide: zn, useClass: zv }, { provide: wd, useFactory: () => { const e = _(RR), t = _(ce), n = _(ba), r = _(_a), o = _(si); return n.scrollOffset && e.setOffset(n.scrollOffset), new MC(o, r, e, t, n) } }, r?.preloadingStrategy ? tP(r.preloadingStrategy).\u0275providers : [], { provide: mv, multi: !0, useFactory: oP }, r?.initialNavigation ? cP(r) : [], r?.bindToComponentInputs ? cn(8, [sC, { provide: va, useExisting: sC }]).\u0275providers : [], [{ provide: PC, useFactory: AC }, { provide: dl, multi: !0, useExisting: PC }]] } } static forChild(n) { return { ngModule: e, providers: [{ provide: Zr, multi: !0, useValue: n }] } } } return e.\u0275fac = function (n) { return new (n || e)(R(xC, 8)) }, e.\u0275mod = Tn({ type: e }), e.\u0275inj = hn({}), e })(); function uP(e) { return "guarded" } function cP(e) { return ["disabled" === e.initialNavigation ? cn(3, [{ provide: rl, multi: !0, useFactory: () => { const t = _(gt); return () => { t.setUpLocationChangeListener() } } }, { provide: Ed, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === e.initialNavigation ? cn(2, [{ provide: Ed, useValue: 0 }, { provide: rl, multi: !0, deps: [tn], useFactory: t => { const n = t.get(lN, Promise.resolve()); return () => n.then(() => new Promise(r => { const o = t.get(gt), i = t.get(NC); IC(o, () => { r(!0) }), t.get(_a).afterPreactivation = () => (r(!0), i.closed ? F(void 0) : i), o.initialNavigation() })) } }]).\u0275providers : []] } const PC = new I(""); let FC = (() => { class e { constructor() { } ngOnInit() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Rt({ type: e, selectors: [["app-home"]], decls: 12, vars: 0, consts: [["id", "bg-picture", 1, ""], [1, "hero", "m-auto", "p-5", "bg-danger", "bg-opacity-50", "text-center", "text-light", "rounded-3"], [1, "big-titel"], ["routerLink", "menu", 1, "btn", "btn-success", "m-2"], [1, "btn", "btn-success", "m-2"]], template: function (n, r) { 1 & n && (T(0, "div", 0)(1, "div", 1)(2, "h1", 2), G(3, "Ristaurante Il Gambero Rosso"), b(), T(4, "p"), G(5, "Delivering great food for more then 18 years!"), b(), T(6, "button", 3)(7, "a"), G(8, "Our Menu"), b()(), T(9, "button", 4)(10, "a"), G(11, "Book a table"), b()()()()) }, dependencies: [Qr], styles: ["#bg-picture[_ngcontent-%COMP%]{background-image:linear-gradient(rgba(0,0,0,.5),rgba(0,0,0,.5)),url(assets/italian_food.jpeg);background-position:center;background-repeat:no-repeat;background-size:cover;display:flex;width:100%;height:90vh}.big-titel[_ngcontent-%COMP%]{font-family:Great Vibes}"] }), e })(), dP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Rt({ type: e, selectors: [["app-about-us"]], decls: 18, vars: 0, consts: [[1, "main", "mt-3"], ["id", "about"], ["src", "assets/tiramisu.jpg", "alt", ""]], template: function (n, r) { 1 & n && (T(0, "div"), ne(1, "br")(2, "br"), b(), T(3, "main", 0)(4, "section", 1)(5, "h2"), G(6, "About Us"), b(), T(7, "p"), G(8, "Welcome to our restaurant, where we strive to provide the best dining experience for our customers. We believe that great food brings people together, and that's why we are passionate about serving delicious meals made from the finest ingredients."), b(), T(9, "p"), G(10, "Our team of talented chefs is dedicated to creating innovative and mouthwatering dishes that satisfy every palate. From appetizers to desserts, our menu offers a wide variety of options to cater to different tastes and dietary preferences."), b(), T(11, "p"), G(12, "At our restaurant, we also take pride in our warm and inviting atmosphere. Whether you're enjoying a romantic dinner for two or celebrating a special occasion with friends and family, our friendly staff will ensure that your experience is memorable."), b(), T(13, "p"), G(14, "We source our ingredients locally and prioritize sustainability, supporting local farmers and producers. Our commitment to quality extends beyond the kitchen to our exceptional customer service. We believe that every guest deserves personalized attention and a dining experience that exceeds expectations."), b(), T(15, "p"), G(16, "Thank you for choosing our restaurant. We look forward to serving you and creating delightful memories around the table."), b(), ne(17, "img", 2), b()()) }, styles: ["body[_ngcontent-%COMP%]{font-family:Arial,sans-serif;margin:0;padding:0}h1[_ngcontent-%COMP%], h2[_ngcontent-%COMP%]{color:#333;font-weight:700;text-shadow:2px 2px 2px white}p[_ngcontent-%COMP%]{line-height:1.5}img[_ngcontent-%COMP%]{height:760px;width:100%}main[_ngcontent-%COMP%]{font-family:Verdana,Geneva,Tahoma,sans-serif;padding:20px;background-color:#add8e6;height:1200px;border-radius:10px;border:1px solid gray;box-shadow:2px 2px 2px #000}#about[_ngcontent-%COMP%]{margin-bottom:30px}"] }), e })(); const kC = [{ img: "assets/diavolo.jpg", name: "Pizza Diavolo", price: 13, description: "In Italian, pizza diavola means \u201cdeviled\u201d pizza. And in this case, deviled means one thing: spicy.", availability: !0 }, { img: "assets/margerita.jpg", name: "Pizza Margerita", price: 7, description: "Margherita is known for its ingredients representing the colors of the Italian flag.", availability: !0 }, { img: "assets/penne.jpg", name: "Italian penne", price: 6, description: "Penne pasta is a tube-shaped dried pasta that originated in Italy.", availability: !1 }, { img: "assets/platter.jpg", name: "Platter", price: 15, description: "A platter is a flat dish or plate, typically oval or circular in shape.", availability: !0 }, { img: "assets/schrimps_spaghetti.jpg", name: "Spaghetti with scampi", price: 17, description: "Shrimp scampi is a seafood dish made of shrimp cooked in a butter, garlic, and white wine sauce.", availability: !1 }, { img: "assets/tiramisu.jpg", name: "Tiramisu", price: 12, description: "Tiramisu is an elegant and rich layered Italian dessert made with espresso, mascarpone, eggs, sugar and cocoa powder.", availability: !0 }]; let _d = (() => { class e { constructor() { this.cart = [] } addToCart(n) { this.cart.push(n) } getCart() { return this.cart } calculateTotal() { let n = 0; for (let r of this.cart) n += r.price; return n } calculateDiscount() { let n = 0, r = this.calculateTotal(); return n = r + .1 * r, n } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = x({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function fP(e, t) { 1 & e && (T(0, "p", 13), G(1, "Not available ! ! !"), b()) } function hP(e, t) { if (1 & e) { const n = function Bg() { return y() }(); T(0, "div", 14)(1, "a", 15), G(2, "Details"), b(), T(3, "button", 16), Vo("click", function () { !function Uf(e) { return P.lFrame.contextLView = e, e[ge] }(n); const o = $o().$implicit; return function zf(e) { return P.lFrame.contextLView = null, e }($o().addToCart(o)) }), G(4, "Add To Cart"), b()() } if (2 & e) { const n = $o().index; de(1), Fs("routerLink", "/dish/", n, "") } } function pP(e, t) { if (1 & e && (T(0, "div")(1, "div", 5), ne(2, "img", 6), T(3, "div", 7)(4, "h5", 8), G(5), b(), ne(6, "hr"), T(7, "p", 9)(8, "span", 10), G(9), b()(), xr(10, fP, 2, 0, "p", 11), xr(11, hP, 5, 1, "div", 12), b()()()), 2 & e) { const n = t.$implicit; de(2), Ho("src", n.img, bo), de(3), Hn(n.name), de(4), Bt("", n.price, " \u20ac"), de(1), Vn("ngIf", !n.availability), de(1), Vn("ngIf", n.availability) } } function yP(e, t) { if (1 & e && (T(0, "p"), G(1), ne(2, "br"), G(3), b()), 2 & e) { const n = $o(); de(1), Bt("Discount of : ", .15 * n.total, " \u20ac "), de(2), Bt(" New Amount to pay : ", n.discount - .15 * n.total, " \u20ac") } } function vP(e, t) { if (1 & e && (T(0, "div", 4)(1, "h2"), G(2, "Dish Details"), b(), ne(3, "img", 5), T(4, "p"), G(5), b(), T(6, "p"), G(7), b(), T(8, "p"), G(9), b(), ne(10, "hr"), b()), 2 & e) { const n = t.$implicit; de(3), Ho("src", n.img, bo), de(2), Hn(n.name), de(2), Bt("", n.price, " \u20ac"), de(2), Hn(n.description) } } const DP = [{ path: "", component: FC }, { path: "home", component: FC }, { path: "menu", component: (() => { class e { constructor(n, r) { this.route = n, this.cartService = r, this.dishes = kC, this.dish = {}, this.index = 0 } addToCart(n) { alert("added to the card"), this.cartService.addToCart(n) } ngOnInit() { this.route.params.subscribe(n => { this.index = +n.indexFromRouting, this.dish = this.dishes[this.index] }) } } return e.\u0275fac = function (n) { return new (n || e)(S(In), S(_d)) }, e.\u0275cmp = Rt({ type: e, selectors: [["app-menu"]], decls: 6, vars: 1, consts: [[1, "head", 2, "height", "100px"], [1, "container", 2, "background-color", "#eeee"], [2, "margin-top", "15px"], [1, "row", "row-cols-lg-3", "row-cols-md-3", "row-cols-sm-2", "row-cols-xs-1"], [4, "ngFor", "ngForOf"], [1, "card", 2, "width", "20rem", "margin-bottom", "15px"], ["alt", "...", 1, "card-img-top", 3, "src"], [1, "card-body"], [1, "card-title"], [1, "card-text"], ["id", "euro"], ["id", "avail", 4, "ngIf"], ["class", "btn", 4, "ngIf"], ["id", "avail"], [1, "btn"], [1, "btn", "btn-primary", "m-4", 3, "routerLink"], [1, "btn", "btn-success", 3, "click"]], template: function (n, r) { 1 & n && (ne(0, "div", 0), T(1, "div", 1)(2, "h2", 2), G(3, "Menu List"), b(), T(4, "div", 3), xr(5, pP, 12, 5, "div", 4), b()()), 2 & n && (de(5), Vn("ngForOf", r.dishes)) }, dependencies: [Fl, kl, Qr], styles: ["#euro[_ngcontent-%COMP%]{color:#00f;background-color:#1fadad48;border-radius:20px}img[_ngcontent-%COMP%]{width:100%;height:200px}.container[_ngcontent-%COMP%]{border-radius:15px;padding:10px}.card-body[_ngcontent-%COMP%]{box-shadow:5px 5px 5px gray}#avail[_ngcontent-%COMP%]{color:red;font-weight:700;font-size:18px}"] }), e })() }, { path: "about-us", component: dP }, { path: "dish/:indexFromRouting", component: (() => { class e { constructor(n, r) { this.route = n, this.cartService = r, this.dish = {}, this.index = 0 } addToCart() { alert("added to the card"), this.cartService.addToCart(this.dish) } ngOnInit() { this.route.params.subscribe(n => { this.index = +n.indexFromRouting, this.dish = kC[this.index] }) } } return e.\u0275fac = function (n) { return new (n || e)(S(In), S(_d)) }, e.\u0275cmp = Rt({ type: e, selectors: [["app-details"]], decls: 15, vars: 4, consts: [[1, "container", 2, "margin-top", "20px", "margin-bottom", "30px"], [2, "width", "400px", 3, "src"], [1, "p-2"], [1, "btn", "btn-primary", 3, "click"]], template: function (n, r) { 1 & n && (T(0, "div"), ne(1, "br")(2, "br"), b(), T(3, "div", 0)(4, "h2"), G(5, "Dish Details"), b(), T(6, "p"), G(7), b(), ne(8, "img", 1), T(9, "p", 2), G(10), b(), T(11, "p"), G(12), b(), T(13, "button", 3), Vo("click", function () { return r.addToCart() }), G(14, "Add To Cart"), b()()), 2 & n && (de(7), Hn(r.dish.name), de(1), Ho("src", r.dish.img, bo), de(2), Bt("", r.dish.price, " \u20ac"), de(2), Hn(r.dish.description)) }, styles: ["p[_ngcontent-%COMP%]{font-size:large;font-family:Cambria,Cochin,Georgia,Times,Times New Roman,serif;font:18px}.container[_ngcontent-%COMP%]{height:auto;width:100%;background-color:#ffebcd;text-align:center;box-shadow:3px 3px 3px gray;border:1px solid gray}.btn[_ngcontent-%COMP%]{margin-bottom:5px}img[_ngcontent-%COMP%]{border:2px solid gray;border-radius:10px;border-style:groove}"] }), e })() }, { path: "cart", component: (() => { class e { constructor(n) { this.cartService = n, this.cart = [], this.total = 0, this.discount = 0 } ngOnInit() { this.cart = this.cartService.getCart(), this.total = this.cartService.calculateTotal(), this.discount = this.cartService.calculateDiscount() } } return e.\u0275fac = function (n) { return new (n || e)(S(_d)) }, e.\u0275cmp = Rt({ type: e, selectors: [["app-cart"]], decls: 17, vars: 4, consts: [[1, "position"], [1, "container_1"], [4, "ngIf"], ["class", "container", "style", "margin-top: 20px; margin-bottom: 30px;", 4, "ngFor", "ngForOf"], [1, "container", 2, "margin-top", "20px", "margin-bottom", "30px"], [2, "width", "400px", 3, "src"]], template: function (n, r) { 1 & n && (T(0, "div"), ne(1, "br")(2, "br")(3, "br"), b(), T(4, "div", 0)(5, "div", 1)(6, "h3"), G(7), b(), ne(8, "hr"), T(9, "p"), G(10, "Amount + Service : "), T(11, "strong"), G(12), b()(), ne(13, "hr"), xr(14, yP, 4, 2, "p", 2), b()(), ne(15, "hr"), xr(16, vP, 11, 4, "div", 3)), 2 & n && (de(7), Bt("Menues Total: ", r.total, "\u20ac"), de(5), Bt("", r.discount, "\u20ac"), de(2), Vn("ngIf", r.total > 40), de(2), Vn("ngForOf", r.cart)) }, dependencies: [Fl, kl], styles: [".position[_ngcontent-%COMP%]{text-align:center}"] }), e })() }]; let CP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Tn({ type: e }), e.\u0275inj = hn({ imports: [OC.forRoot(DP), OC] }), e })(), wP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Rt({ type: e, selectors: [["app-navbar"]], decls: 17, vars: 0, consts: [[1, "navbar", "navbar-expand-lg", "fixed-top", "bg-body-tertiary"], [1, "container-fluid"], ["routerLink", "/", 1, "navbar-brand"], ["src", "assets/schrimps.jpg", "alt", "Logo", "width", "30px", "height", "30px", 1, "d-inline-block", "align-text-top"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#navbarNavAltMarkup", "aria-controls", "navbarNavAltMarkup", "aria-expanded", "false", "aria-label", "Toggle navigation", 1, "navbar-toggler"], [1, "navbar-toggler-icon"], ["id", "navbarNavAltMarkup", 1, "collapse", "navbar-collapse"], [1, "navbar-nav"], ["aria-current", "page", "routerLink", "/", 1, "nav-link", "active"], ["routerLink", "/about-us", 1, "nav-link"], ["routerLink", "/menu", 1, "nav-link"], ["routerLink", "/cart", 1, "nav-link"]], template: function (n, r) { 1 & n && (T(0, "nav", 0)(1, "div", 1)(2, "a", 2), ne(3, "img", 3), G(4, " Ristorante "), b(), T(5, "button", 4), ne(6, "span", 5), b(), T(7, "div", 6)(8, "div", 7)(9, "a", 8), G(10, "Home"), b(), T(11, "a", 9), G(12, "About us"), b(), T(13, "a", 10), G(14, "Menu"), b(), T(15, "a", 11), G(16, "Cart"), b()()()()()) }, dependencies: [Qr], styles: [".navbar[_ngcontent-%COMP%]{height:60px;font-size:20px;box-shadow:0 2px 2px gray;text-shadow:2px 2px 2px gray}a[_ngcontent-%COMP%]:hover{color:#4682b4;font-size:24px}"] }), e })(), EP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Rt({ type: e, selectors: [["app-footer"]], decls: 31, vars: 0, consts: [["id", "footer", 1, "fixed-bottom"], [1, "bg-color"], ["id", "socialmedia", 1, "socialmedia"], ["href", "#facebook"], [1, "fa-brands", "fa-border", "fa-square-facebook"], ["href", "#twitter"], [1, "fa-brands", "fa-border", "fa-twitter"], ["href", "#google"], [1, "fa-brands", "fa-border", "fa-google"], ["href", "#instagram"], [1, "fa-brands", "fa-border", "fa-instagram"], ["href", "#linkedin"], [1, "fa-brands", "fa-border", "fa-linkedin-in"], ["href", "#github"], [1, "fa-brands", "fa-border", "fa-github"], [1, "newsletter"], ["for", "fname"], ["type", "text", "id", "fname", "name", "fname"], ["type", "button"], [1, "author"]], template: function (n, r) { 1 & n && (ne(0, "br")(1, "br")(2, "br")(3, "br")(4, "br")(5, "br"), T(6, "footer", 0)(7, "div", 1)(8, "div", 2)(9, "a", 3), ne(10, "i", 4), b(), T(11, "a", 5), ne(12, "i", 6), b(), T(13, "a", 7), ne(14, "i", 8), b(), T(15, "a", 9), ne(16, "i", 10), b(), T(17, "a", 11), ne(18, "i", 12), b(), T(19, "a", 13), ne(20, "i", 14), b()(), T(21, "div", 15)(22, "form")(23, "label", 16), G(24, "Sign up for our newsletter"), b(), ne(25, "input", 17), b(), T(26, "button", 18), G(27, "Subscribe"), b()(), T(28, "div", 19)(29, "p"), G(30, "\xa9 2023 copyright: Emelin Bilajbegovic"), b()()()()) }, styles: ["footer[_ngcontent-%COMP%]{background-color:#000;margin-top:100px}footer[_ngcontent-%COMP%]   .newsletter[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;color:#fff;font-weight:700;padding-top:15px;padding-bottom:18px}footer[_ngcontent-%COMP%]   .newsletter[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{margin-right:20px}button[_ngcontent-%COMP%]{font-size:15px;padding:5px;margin-left:20px;background-color:gray;color:#fff}button[_ngcontent-%COMP%]:hover{color:#000}footer[_ngcontent-%COMP%]   .socialmedia[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;height:40px;padding-top:10px;background-color:#000}footer[_ngcontent-%COMP%]   .socialmedia[_ngcontent-%COMP%]   .fa-brands[_ngcontent-%COMP%]{border-radius:.2em;padding:.5em}footer[_ngcontent-%COMP%]   .socialmedia[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:#fff;margin:5px}footer[_ngcontent-%COMP%]   .socialmedia[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:#00ff7f}footer[_ngcontent-%COMP%]   .author[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;height:25px;font-size:15px}footer[_ngcontent-%COMP%]   .author[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:15px;color:#fff}"] }), e })(), _P = (() => { class e { constructor() { this.title = "Ristorante Il Gambero Rosso" } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = Rt({ type: e, selectors: [["app-root"]], decls: 3, vars: 0, template: function (n, r) { 1 & n && ne(0, "app-navbar")(1, "router-outlet")(2, "app-footer") }, dependencies: [pd, wP, EP], styles: ["body[_ngcontent-%COMP%]{background-color:#6495ed}"] }), e })(), bP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Tn({ type: e, bootstrap: [_P] }), e.\u0275inj = hn({ imports: [Ix, CP] }), e })(); _x().bootstrapModule(bP).catch(e => console.error(e)) } }, te => { te(te.s = 195) }]);